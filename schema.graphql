schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "circuits"
"""
type circuits {
  country: String
  f1_key: Int
  id: String!
  location: String
  name: String

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!
}

"""
aggregated selection of "circuits"
"""
type circuits_aggregate {
  aggregate: circuits_aggregate_fields
  nodes: [circuits!]!
}

"""
aggregate fields of "circuits"
"""
type circuits_aggregate_fields {
  avg: circuits_avg_fields
  count(columns: [circuits_select_column!], distinct: Boolean): Int!
  max: circuits_max_fields
  min: circuits_min_fields
  stddev: circuits_stddev_fields
  stddev_pop: circuits_stddev_pop_fields
  stddev_samp: circuits_stddev_samp_fields
  sum: circuits_sum_fields
  var_pop: circuits_var_pop_fields
  var_samp: circuits_var_samp_fields
  variance: circuits_variance_fields
}

"""
aggregate avg on columns
"""
type circuits_avg_fields {
  f1_key: Float
}

"""
Boolean expression to filter rows from the table "circuits". All fields are combined with a logical 'AND'.
"""
input circuits_bool_exp {
  _and: [circuits_bool_exp!]
  _not: circuits_bool_exp
  _or: [circuits_bool_exp!]
  country: String_comparison_exp
  f1_key: Int_comparison_exp
  id: String_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
}

"""
unique or primary key constraints on table "circuits"
"""
enum circuits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  circuits_pkey
}

"""
input type for incrementing numeric columns in table "circuits"
"""
input circuits_inc_input {
  f1_key: Int
}

"""
input type for inserting data into table "circuits"
"""
input circuits_insert_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
  sessions: sessions_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type circuits_max_fields {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate min on columns
"""
type circuits_min_fields {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
response of any mutation on the table "circuits"
"""
type circuits_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [circuits!]!
}

"""
input type for inserting object relation for remote table "circuits"
"""
input circuits_obj_rel_insert_input {
  data: circuits_insert_input!

  """
  upsert condition
  """
  on_conflict: circuits_on_conflict
}

"""
on_conflict condition type for table "circuits"
"""
input circuits_on_conflict {
  constraint: circuits_constraint!
  update_columns: [circuits_update_column!]! = []
  where: circuits_bool_exp
}

"""
Ordering options when selecting data from "circuits".
"""
input circuits_order_by {
  country: order_by
  f1_key: order_by
  id: order_by
  location: order_by
  name: order_by
  sessions_aggregate: sessions_aggregate_order_by
}

"""
primary key columns input for table: circuits
"""
input circuits_pk_columns_input {
  id: String!
}

"""
select columns of table "circuits"
"""
enum circuits_select_column {
  """
  column name
  """
  country

  """
  column name
  """
  f1_key

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name
}

"""
input type for updating data in table "circuits"
"""
input circuits_set_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate stddev on columns
"""
type circuits_stddev_fields {
  f1_key: Float
}

"""
aggregate stddev_pop on columns
"""
type circuits_stddev_pop_fields {
  f1_key: Float
}

"""
aggregate stddev_samp on columns
"""
type circuits_stddev_samp_fields {
  f1_key: Float
}

"""
Streaming cursor of the table "circuits"
"""
input circuits_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: circuits_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input circuits_stream_cursor_value_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate sum on columns
"""
type circuits_sum_fields {
  f1_key: Int
}

"""
update columns of table "circuits"
"""
enum circuits_update_column {
  """
  column name
  """
  country

  """
  column name
  """
  f1_key

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name
}

input circuits_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: circuits_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: circuits_set_input

  """
  filter the rows which have to be updated
  """
  where: circuits_bool_exp!
}

"""
aggregate var_pop on columns
"""
type circuits_var_pop_fields {
  f1_key: Float
}

"""
aggregate var_samp on columns
"""
type circuits_var_samp_fields {
  f1_key: Float
}

"""
aggregate variance on columns
"""
type circuits_variance_fields {
  f1_key: Float
}

"""
columns and relationships of "constructor_standings"
"""
type constructor_standings {
  """
  An object relationship
  """
  constructorByConstructorId: constructors
  constructor_id: String
  id: String!
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregated selection of "constructor_standings"
"""
type constructor_standings_aggregate {
  aggregate: constructor_standings_aggregate_fields
  nodes: [constructor_standings!]!
}

input constructor_standings_aggregate_bool_exp {
  count: constructor_standings_aggregate_bool_exp_count
}

input constructor_standings_aggregate_bool_exp_count {
  arguments: [constructor_standings_select_column!]
  distinct: Boolean
  filter: constructor_standings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "constructor_standings"
"""
type constructor_standings_aggregate_fields {
  avg: constructor_standings_avg_fields
  count(
    columns: [constructor_standings_select_column!]
    distinct: Boolean
  ): Int!
  max: constructor_standings_max_fields
  min: constructor_standings_min_fields
  stddev: constructor_standings_stddev_fields
  stddev_pop: constructor_standings_stddev_pop_fields
  stddev_samp: constructor_standings_stddev_samp_fields
  sum: constructor_standings_sum_fields
  var_pop: constructor_standings_var_pop_fields
  var_samp: constructor_standings_var_samp_fields
  variance: constructor_standings_variance_fields
}

"""
order by aggregate values of table "constructor_standings"
"""
input constructor_standings_aggregate_order_by {
  avg: constructor_standings_avg_order_by
  count: order_by
  max: constructor_standings_max_order_by
  min: constructor_standings_min_order_by
  stddev: constructor_standings_stddev_order_by
  stddev_pop: constructor_standings_stddev_pop_order_by
  stddev_samp: constructor_standings_stddev_samp_order_by
  sum: constructor_standings_sum_order_by
  var_pop: constructor_standings_var_pop_order_by
  var_samp: constructor_standings_var_samp_order_by
  variance: constructor_standings_variance_order_by
}

"""
input type for inserting array relation for remote table "constructor_standings"
"""
input constructor_standings_arr_rel_insert_input {
  data: [constructor_standings_insert_input!]!

  """
  upsert condition
  """
  on_conflict: constructor_standings_on_conflict
}

"""
aggregate avg on columns
"""
type constructor_standings_avg_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by avg() on columns of table "constructor_standings"
"""
input constructor_standings_avg_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "constructor_standings". All fields are combined with a logical 'AND'.
"""
input constructor_standings_bool_exp {
  _and: [constructor_standings_bool_exp!]
  _not: constructor_standings_bool_exp
  _or: [constructor_standings_bool_exp!]
  constructorByConstructorId: constructors_bool_exp
  constructor_id: String_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  position: Int_comparison_exp
  position_text: String_comparison_exp
  season: Int_comparison_exp
  wins: Int_comparison_exp
}

"""
unique or primary key constraints on table "constructor_standings"
"""
enum constructor_standings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  constructor_standings_pkey
}

"""
input type for incrementing numeric columns in table "constructor_standings"
"""
input constructor_standings_inc_input {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
input type for inserting data into table "constructor_standings"
"""
input constructor_standings_insert_input {
  constructorByConstructorId: constructors_obj_rel_insert_input
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate max on columns
"""
type constructor_standings_max_fields {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by max() on columns of table "constructor_standings"
"""
input constructor_standings_max_order_by {
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
aggregate min on columns
"""
type constructor_standings_min_fields {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by min() on columns of table "constructor_standings"
"""
input constructor_standings_min_order_by {
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
response of any mutation on the table "constructor_standings"
"""
type constructor_standings_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [constructor_standings!]!
}

"""
on_conflict condition type for table "constructor_standings"
"""
input constructor_standings_on_conflict {
  constraint: constructor_standings_constraint!
  update_columns: [constructor_standings_update_column!]! = []
  where: constructor_standings_bool_exp
}

"""
Ordering options when selecting data from "constructor_standings".
"""
input constructor_standings_order_by {
  constructorByConstructorId: constructors_order_by
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
primary key columns input for table: constructor_standings
"""
input constructor_standings_pk_columns_input {
  id: String!
}

"""
select columns of table "constructor_standings"
"""
enum constructor_standings_select_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

"""
input type for updating data in table "constructor_standings"
"""
input constructor_standings_set_input {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate stddev on columns
"""
type constructor_standings_stddev_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_pop on columns
"""
type constructor_standings_stddev_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_samp on columns
"""
type constructor_standings_stddev_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Streaming cursor of the table "constructor_standings"
"""
input constructor_standings_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: constructor_standings_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input constructor_standings_stream_cursor_value_input {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate sum on columns
"""
type constructor_standings_sum_fields {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
order by sum() on columns of table "constructor_standings"
"""
input constructor_standings_sum_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
update columns of table "constructor_standings"
"""
enum constructor_standings_update_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

input constructor_standings_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: constructor_standings_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: constructor_standings_set_input

  """
  filter the rows which have to be updated
  """
  where: constructor_standings_bool_exp!
}

"""
aggregate var_pop on columns
"""
type constructor_standings_var_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_pop() on columns of table "constructor_standings"
"""
input constructor_standings_var_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate var_samp on columns
"""
type constructor_standings_var_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_samp() on columns of table "constructor_standings"
"""
input constructor_standings_var_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate variance on columns
"""
type constructor_standings_variance_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by variance() on columns of table "constructor_standings"
"""
input constructor_standings_variance_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
columns and relationships of "constructors"
"""
type constructors {
  color: String

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!
  engine: String
  ergast_id: String
  id: String!
  name: String
  nationality: String
  start_year: Int
}

"""
aggregated selection of "constructors"
"""
type constructors_aggregate {
  aggregate: constructors_aggregate_fields
  nodes: [constructors!]!
}

"""
aggregate fields of "constructors"
"""
type constructors_aggregate_fields {
  avg: constructors_avg_fields
  count(columns: [constructors_select_column!], distinct: Boolean): Int!
  max: constructors_max_fields
  min: constructors_min_fields
  stddev: constructors_stddev_fields
  stddev_pop: constructors_stddev_pop_fields
  stddev_samp: constructors_stddev_samp_fields
  sum: constructors_sum_fields
  var_pop: constructors_var_pop_fields
  var_samp: constructors_var_samp_fields
  variance: constructors_variance_fields
}

"""
aggregate avg on columns
"""
type constructors_avg_fields {
  start_year: Float
}

"""
Boolean expression to filter rows from the table "constructors". All fields are combined with a logical 'AND'.
"""
input constructors_bool_exp {
  _and: [constructors_bool_exp!]
  _not: constructors_bool_exp
  _or: [constructors_bool_exp!]
  color: String_comparison_exp
  constructor_standings: constructor_standings_bool_exp
  constructor_standings_aggregate: constructor_standings_aggregate_bool_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  engine: String_comparison_exp
  ergast_id: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  nationality: String_comparison_exp
  start_year: Int_comparison_exp
}

"""
unique or primary key constraints on table "constructors"
"""
enum constructors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  constructors_pkey
}

"""
input type for incrementing numeric columns in table "constructors"
"""
input constructors_inc_input {
  start_year: Int
}

"""
input type for inserting data into table "constructors"
"""
input constructors_insert_input {
  color: String
  constructor_standings: constructor_standings_arr_rel_insert_input
  driver_sessions: driver_sessions_arr_rel_insert_input
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate max on columns
"""
type constructors_max_fields {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate min on columns
"""
type constructors_min_fields {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
response of any mutation on the table "constructors"
"""
type constructors_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [constructors!]!
}

"""
input type for inserting object relation for remote table "constructors"
"""
input constructors_obj_rel_insert_input {
  data: constructors_insert_input!

  """
  upsert condition
  """
  on_conflict: constructors_on_conflict
}

"""
on_conflict condition type for table "constructors"
"""
input constructors_on_conflict {
  constraint: constructors_constraint!
  update_columns: [constructors_update_column!]! = []
  where: constructors_bool_exp
}

"""
Ordering options when selecting data from "constructors".
"""
input constructors_order_by {
  color: order_by
  constructor_standings_aggregate: constructor_standings_aggregate_order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  engine: order_by
  ergast_id: order_by
  id: order_by
  name: order_by
  nationality: order_by
  start_year: order_by
}

"""
primary key columns input for table: constructors
"""
input constructors_pk_columns_input {
  id: String!
}

"""
select columns of table "constructors"
"""
enum constructors_select_column {
  """
  column name
  """
  color

  """
  column name
  """
  engine

  """
  column name
  """
  ergast_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  nationality

  """
  column name
  """
  start_year
}

"""
input type for updating data in table "constructors"
"""
input constructors_set_input {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate stddev on columns
"""
type constructors_stddev_fields {
  start_year: Float
}

"""
aggregate stddev_pop on columns
"""
type constructors_stddev_pop_fields {
  start_year: Float
}

"""
aggregate stddev_samp on columns
"""
type constructors_stddev_samp_fields {
  start_year: Float
}

"""
Streaming cursor of the table "constructors"
"""
input constructors_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: constructors_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input constructors_stream_cursor_value_input {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate sum on columns
"""
type constructors_sum_fields {
  start_year: Int
}

"""
update columns of table "constructors"
"""
enum constructors_update_column {
  """
  column name
  """
  color

  """
  column name
  """
  engine

  """
  column name
  """
  ergast_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  nationality

  """
  column name
  """
  start_year
}

input constructors_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: constructors_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: constructors_set_input

  """
  filter the rows which have to be updated
  """
  where: constructors_bool_exp!
}

"""
aggregate var_pop on columns
"""
type constructors_var_pop_fields {
  start_year: Float
}

"""
aggregate var_samp on columns
"""
type constructors_var_samp_fields {
  start_year: Float
}

"""
aggregate variance on columns
"""
type constructors_variance_fields {
  start_year: Float
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
columns and relationships of "driver_sessions"
"""
type driver_sessions {
  """
  An object relationship
  """
  constructorByConstructorId: constructors
  constructor_id: String

  """
  An object relationship
  """
  driver: drivers
  driver_id: String
  id: String!

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  An object relationship
  """
  session: sessions
  session_id: String

  """
  An array relationship
  """
  telemetries(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  An aggregate relationship
  """
  telemetries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!
}

"""
aggregated selection of "driver_sessions"
"""
type driver_sessions_aggregate {
  aggregate: driver_sessions_aggregate_fields
  nodes: [driver_sessions!]!
}

input driver_sessions_aggregate_bool_exp {
  count: driver_sessions_aggregate_bool_exp_count
}

input driver_sessions_aggregate_bool_exp_count {
  arguments: [driver_sessions_select_column!]
  distinct: Boolean
  filter: driver_sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "driver_sessions"
"""
type driver_sessions_aggregate_fields {
  count(columns: [driver_sessions_select_column!], distinct: Boolean): Int!
  max: driver_sessions_max_fields
  min: driver_sessions_min_fields
}

"""
order by aggregate values of table "driver_sessions"
"""
input driver_sessions_aggregate_order_by {
  count: order_by
  max: driver_sessions_max_order_by
  min: driver_sessions_min_order_by
}

"""
input type for inserting array relation for remote table "driver_sessions"
"""
input driver_sessions_arr_rel_insert_input {
  data: [driver_sessions_insert_input!]!

  """
  upsert condition
  """
  on_conflict: driver_sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "driver_sessions". All fields are combined with a logical 'AND'.
"""
input driver_sessions_bool_exp {
  _and: [driver_sessions_bool_exp!]
  _not: driver_sessions_bool_exp
  _or: [driver_sessions_bool_exp!]
  constructorByConstructorId: constructors_bool_exp
  constructor_id: String_comparison_exp
  driver: drivers_bool_exp
  driver_id: String_comparison_exp
  id: String_comparison_exp
  laps: laps_bool_exp
  laps_aggregate: laps_aggregate_bool_exp
  results: results_bool_exp
  results_aggregate: results_aggregate_bool_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  telemetries: telemetry_bool_exp
  telemetries_aggregate: telemetry_aggregate_bool_exp
}

"""
unique or primary key constraints on table "driver_sessions"
"""
enum driver_sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  driver_sessions_pkey
}

"""
input type for inserting data into table "driver_sessions"
"""
input driver_sessions_insert_input {
  constructorByConstructorId: constructors_obj_rel_insert_input
  constructor_id: String
  driver: drivers_obj_rel_insert_input
  driver_id: String
  id: String
  laps: laps_arr_rel_insert_input
  results: results_arr_rel_insert_input
  session: sessions_obj_rel_insert_input
  session_id: String
  telemetries: telemetry_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type driver_sessions_max_fields {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
order by max() on columns of table "driver_sessions"
"""
input driver_sessions_max_order_by {
  constructor_id: order_by
  driver_id: order_by
  id: order_by
  session_id: order_by
}

"""
aggregate min on columns
"""
type driver_sessions_min_fields {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
order by min() on columns of table "driver_sessions"
"""
input driver_sessions_min_order_by {
  constructor_id: order_by
  driver_id: order_by
  id: order_by
  session_id: order_by
}

"""
response of any mutation on the table "driver_sessions"
"""
type driver_sessions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [driver_sessions!]!
}

"""
input type for inserting object relation for remote table "driver_sessions"
"""
input driver_sessions_obj_rel_insert_input {
  data: driver_sessions_insert_input!

  """
  upsert condition
  """
  on_conflict: driver_sessions_on_conflict
}

"""
on_conflict condition type for table "driver_sessions"
"""
input driver_sessions_on_conflict {
  constraint: driver_sessions_constraint!
  update_columns: [driver_sessions_update_column!]! = []
  where: driver_sessions_bool_exp
}

"""
Ordering options when selecting data from "driver_sessions".
"""
input driver_sessions_order_by {
  constructorByConstructorId: constructors_order_by
  constructor_id: order_by
  driver: drivers_order_by
  driver_id: order_by
  id: order_by
  laps_aggregate: laps_aggregate_order_by
  results_aggregate: results_aggregate_order_by
  session: sessions_order_by
  session_id: order_by
  telemetries_aggregate: telemetry_aggregate_order_by
}

"""
primary key columns input for table: driver_sessions
"""
input driver_sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "driver_sessions"
"""
enum driver_sessions_select_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  session_id
}

"""
input type for updating data in table "driver_sessions"
"""
input driver_sessions_set_input {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
Streaming cursor of the table "driver_sessions"
"""
input driver_sessions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: driver_sessions_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input driver_sessions_stream_cursor_value_input {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
update columns of table "driver_sessions"
"""
enum driver_sessions_update_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  session_id
}

input driver_sessions_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: driver_sessions_set_input

  """
  filter the rows which have to be updated
  """
  where: driver_sessions_bool_exp!
}

"""
columns and relationships of "driver_standings"
"""
type driver_standings {
  """
  An object relationship
  """
  driver: drivers
  driver_id: String
  id: String!
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregated selection of "driver_standings"
"""
type driver_standings_aggregate {
  aggregate: driver_standings_aggregate_fields
  nodes: [driver_standings!]!
}

input driver_standings_aggregate_bool_exp {
  count: driver_standings_aggregate_bool_exp_count
}

input driver_standings_aggregate_bool_exp_count {
  arguments: [driver_standings_select_column!]
  distinct: Boolean
  filter: driver_standings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "driver_standings"
"""
type driver_standings_aggregate_fields {
  avg: driver_standings_avg_fields
  count(columns: [driver_standings_select_column!], distinct: Boolean): Int!
  max: driver_standings_max_fields
  min: driver_standings_min_fields
  stddev: driver_standings_stddev_fields
  stddev_pop: driver_standings_stddev_pop_fields
  stddev_samp: driver_standings_stddev_samp_fields
  sum: driver_standings_sum_fields
  var_pop: driver_standings_var_pop_fields
  var_samp: driver_standings_var_samp_fields
  variance: driver_standings_variance_fields
}

"""
order by aggregate values of table "driver_standings"
"""
input driver_standings_aggregate_order_by {
  avg: driver_standings_avg_order_by
  count: order_by
  max: driver_standings_max_order_by
  min: driver_standings_min_order_by
  stddev: driver_standings_stddev_order_by
  stddev_pop: driver_standings_stddev_pop_order_by
  stddev_samp: driver_standings_stddev_samp_order_by
  sum: driver_standings_sum_order_by
  var_pop: driver_standings_var_pop_order_by
  var_samp: driver_standings_var_samp_order_by
  variance: driver_standings_variance_order_by
}

"""
input type for inserting array relation for remote table "driver_standings"
"""
input driver_standings_arr_rel_insert_input {
  data: [driver_standings_insert_input!]!

  """
  upsert condition
  """
  on_conflict: driver_standings_on_conflict
}

"""
aggregate avg on columns
"""
type driver_standings_avg_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by avg() on columns of table "driver_standings"
"""
input driver_standings_avg_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "driver_standings". All fields are combined with a logical 'AND'.
"""
input driver_standings_bool_exp {
  _and: [driver_standings_bool_exp!]
  _not: driver_standings_bool_exp
  _or: [driver_standings_bool_exp!]
  driver: drivers_bool_exp
  driver_id: String_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  position: Int_comparison_exp
  position_text: String_comparison_exp
  season: Int_comparison_exp
  wins: Int_comparison_exp
}

"""
unique or primary key constraints on table "driver_standings"
"""
enum driver_standings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  driver_standings_pkey
}

"""
input type for incrementing numeric columns in table "driver_standings"
"""
input driver_standings_inc_input {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
input type for inserting data into table "driver_standings"
"""
input driver_standings_insert_input {
  driver: drivers_obj_rel_insert_input
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate max on columns
"""
type driver_standings_max_fields {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by max() on columns of table "driver_standings"
"""
input driver_standings_max_order_by {
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
aggregate min on columns
"""
type driver_standings_min_fields {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by min() on columns of table "driver_standings"
"""
input driver_standings_min_order_by {
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
response of any mutation on the table "driver_standings"
"""
type driver_standings_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [driver_standings!]!
}

"""
on_conflict condition type for table "driver_standings"
"""
input driver_standings_on_conflict {
  constraint: driver_standings_constraint!
  update_columns: [driver_standings_update_column!]! = []
  where: driver_standings_bool_exp
}

"""
Ordering options when selecting data from "driver_standings".
"""
input driver_standings_order_by {
  driver: drivers_order_by
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
primary key columns input for table: driver_standings
"""
input driver_standings_pk_columns_input {
  id: String!
}

"""
select columns of table "driver_standings"
"""
enum driver_standings_select_column {
  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

"""
input type for updating data in table "driver_standings"
"""
input driver_standings_set_input {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate stddev on columns
"""
type driver_standings_stddev_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev() on columns of table "driver_standings"
"""
input driver_standings_stddev_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_pop on columns
"""
type driver_standings_stddev_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "driver_standings"
"""
input driver_standings_stddev_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_samp on columns
"""
type driver_standings_stddev_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "driver_standings"
"""
input driver_standings_stddev_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Streaming cursor of the table "driver_standings"
"""
input driver_standings_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: driver_standings_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input driver_standings_stream_cursor_value_input {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate sum on columns
"""
type driver_standings_sum_fields {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
order by sum() on columns of table "driver_standings"
"""
input driver_standings_sum_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
update columns of table "driver_standings"
"""
enum driver_standings_update_column {
  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

input driver_standings_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: driver_standings_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: driver_standings_set_input

  """
  filter the rows which have to be updated
  """
  where: driver_standings_bool_exp!
}

"""
aggregate var_pop on columns
"""
type driver_standings_var_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_pop() on columns of table "driver_standings"
"""
input driver_standings_var_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate var_samp on columns
"""
type driver_standings_var_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_samp() on columns of table "driver_standings"
"""
input driver_standings_var_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate variance on columns
"""
type driver_standings_variance_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by variance() on columns of table "driver_standings"
"""
input driver_standings_variance_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
columns and relationships of "drivers"
"""
type drivers {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String!
  last_name: String
  nationality: String
  number: String
}

"""
aggregated selection of "drivers"
"""
type drivers_aggregate {
  aggregate: drivers_aggregate_fields
  nodes: [drivers!]!
}

"""
aggregate fields of "drivers"
"""
type drivers_aggregate_fields {
  count(columns: [drivers_select_column!], distinct: Boolean): Int!
  max: drivers_max_fields
  min: drivers_min_fields
}

"""
Boolean expression to filter rows from the table "drivers". All fields are combined with a logical 'AND'.
"""
input drivers_bool_exp {
  _and: [drivers_bool_exp!]
  _not: drivers_bool_exp
  _or: [drivers_bool_exp!]
  abbreviation: String_comparison_exp
  broadcast_name: String_comparison_exp
  country_code: String_comparison_exp
  date_of_birth: String_comparison_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  driver_standings: driver_standings_bool_exp
  driver_standings_aggregate: driver_standings_aggregate_bool_exp
  ergast_id: String_comparison_exp
  first_name: String_comparison_exp
  full_name: String_comparison_exp
  headshot_url: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
  nationality: String_comparison_exp
  number: String_comparison_exp
}

"""
unique or primary key constraints on table "drivers"
"""
enum drivers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  drivers_pkey
}

"""
input type for inserting data into table "drivers"
"""
input drivers_insert_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  driver_sessions: driver_sessions_arr_rel_insert_input
  driver_standings: driver_standings_arr_rel_insert_input
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
aggregate max on columns
"""
type drivers_max_fields {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
aggregate min on columns
"""
type drivers_min_fields {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
response of any mutation on the table "drivers"
"""
type drivers_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [drivers!]!
}

"""
input type for inserting object relation for remote table "drivers"
"""
input drivers_obj_rel_insert_input {
  data: drivers_insert_input!

  """
  upsert condition
  """
  on_conflict: drivers_on_conflict
}

"""
on_conflict condition type for table "drivers"
"""
input drivers_on_conflict {
  constraint: drivers_constraint!
  update_columns: [drivers_update_column!]! = []
  where: drivers_bool_exp
}

"""
Ordering options when selecting data from "drivers".
"""
input drivers_order_by {
  abbreviation: order_by
  broadcast_name: order_by
  country_code: order_by
  date_of_birth: order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  driver_standings_aggregate: driver_standings_aggregate_order_by
  ergast_id: order_by
  first_name: order_by
  full_name: order_by
  headshot_url: order_by
  id: order_by
  last_name: order_by
  nationality: order_by
  number: order_by
}

"""
primary key columns input for table: drivers
"""
input drivers_pk_columns_input {
  id: String!
}

"""
select columns of table "drivers"
"""
enum drivers_select_column {
  """
  column name
  """
  abbreviation

  """
  column name
  """
  broadcast_name

  """
  column name
  """
  country_code

  """
  column name
  """
  date_of_birth

  """
  column name
  """
  ergast_id

  """
  column name
  """
  first_name

  """
  column name
  """
  full_name

  """
  column name
  """
  headshot_url

  """
  column name
  """
  id

  """
  column name
  """
  last_name

  """
  column name
  """
  nationality

  """
  column name
  """
  number
}

"""
input type for updating data in table "drivers"
"""
input drivers_set_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
Streaming cursor of the table "drivers"
"""
input drivers_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: drivers_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input drivers_stream_cursor_value_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
update columns of table "drivers"
"""
enum drivers_update_column {
  """
  column name
  """
  abbreviation

  """
  column name
  """
  broadcast_name

  """
  column name
  """
  country_code

  """
  column name
  """
  date_of_birth

  """
  column name
  """
  ergast_id

  """
  column name
  """
  first_name

  """
  column name
  """
  full_name

  """
  column name
  """
  headshot_url

  """
  column name
  """
  id

  """
  column name
  """
  last_name

  """
  column name
  """
  nationality

  """
  column name
  """
  number
}

input drivers_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: drivers_set_input

  """
  filter the rows which have to be updated
  """
  where: drivers_bool_exp!
}

scalar event_format_choices

"""
Boolean expression to compare columns of type "event_format_choices". All fields are combined with logical 'AND'.
"""
input event_format_choices_comparison_exp {
  _eq: event_format_choices
  _gt: event_format_choices
  _gte: event_format_choices
  _in: [event_format_choices!]
  _is_null: Boolean
  _lt: event_format_choices
  _lte: event_format_choices
  _neq: event_format_choices
  _nin: [event_format_choices!]
}

"""
columns and relationships of "events"
"""
type events {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String!
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!
  year: Int
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  avg: events_avg_fields
  count(columns: [events_select_column!], distinct: Boolean): Int!
  max: events_max_fields
  min: events_min_fields
  stddev: events_stddev_fields
  stddev_pop: events_stddev_pop_fields
  stddev_samp: events_stddev_samp_fields
  sum: events_sum_fields
  var_pop: events_var_pop_fields
  var_samp: events_var_samp_fields
  variance: events_variance_fields
}

"""
aggregate avg on columns
"""
type events_avg_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  country: String_comparison_exp
  date: String_comparison_exp
  f1_api_support: Boolean_comparison_exp
  format: event_format_choices_comparison_exp
  id: String_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  official_name: String_comparison_exp
  round_number: Int_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
  year: Int_comparison_exp
}

"""
unique or primary key constraints on table "events"
"""
enum events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  events_pkey
}

"""
input type for incrementing numeric columns in table "events"
"""
input events_inc_input {
  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  sessions: sessions_arr_rel_insert_input
  year: Int
}

"""
aggregate max on columns
"""
type events_max_fields {
  country: String
  date: String
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate min on columns
"""
type events_min_fields {
  country: String
  date: String
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [events!]!
}

"""
input type for inserting object relation for remote table "events"
"""
input events_obj_rel_insert_input {
  data: events_insert_input!

  """
  upsert condition
  """
  on_conflict: events_on_conflict
}

"""
on_conflict condition type for table "events"
"""
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]! = []
  where: events_bool_exp
}

"""
Ordering options when selecting data from "events".
"""
input events_order_by {
  country: order_by
  date: order_by
  f1_api_support: order_by
  format: order_by
  id: order_by
  location: order_by
  name: order_by
  official_name: order_by
  round_number: order_by
  sessions_aggregate: sessions_aggregate_order_by
  year: order_by
}

"""
primary key columns input for table: events
"""
input events_pk_columns_input {
  id: String!
}

"""
select columns of table "events"
"""
enum events_select_column {
  """
  column name
  """
  country

  """
  column name
  """
  date

  """
  column name
  """
  f1_api_support

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name

  """
  column name
  """
  official_name

  """
  column name
  """
  round_number

  """
  column name
  """
  year
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate stddev on columns
"""
type events_stddev_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate stddev_pop on columns
"""
type events_stddev_pop_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate stddev_samp on columns
"""
type events_stddev_samp_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
Streaming cursor of the table "events"
"""
input events_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: events_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input events_stream_cursor_value_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate sum on columns
"""
type events_sum_fields {
  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
update columns of table "events"
"""
enum events_update_column {
  """
  column name
  """
  country

  """
  column name
  """
  date

  """
  column name
  """
  f1_api_support

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name

  """
  column name
  """
  official_name

  """
  column name
  """
  round_number

  """
  column name
  """
  year
}

input events_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: events_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: events_set_input

  """
  filter the rows which have to be updated
  """
  where: events_bool_exp!
}

"""
aggregate var_pop on columns
"""
type events_var_pop_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate var_samp on columns
"""
type events_var_samp_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate variance on columns
"""
type events_variance_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
columns and relationships of "laps"
"""
type laps {
  compound: tyre_compounds

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String
  fresh_tyre: Boolean
  id: String!
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregated selection of "laps"
"""
type laps_aggregate {
  aggregate: laps_aggregate_fields
  nodes: [laps!]!
}

input laps_aggregate_bool_exp {
  bool_and: laps_aggregate_bool_exp_bool_and
  bool_or: laps_aggregate_bool_exp_bool_or
  count: laps_aggregate_bool_exp_count
}

input laps_aggregate_bool_exp_bool_and {
  arguments: laps_select_column_laps_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Boolean_comparison_exp!
}

input laps_aggregate_bool_exp_bool_or {
  arguments: laps_select_column_laps_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Boolean_comparison_exp!
}

input laps_aggregate_bool_exp_count {
  arguments: [laps_select_column!]
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "laps"
"""
type laps_aggregate_fields {
  avg: laps_avg_fields
  count(columns: [laps_select_column!], distinct: Boolean): Int!
  max: laps_max_fields
  min: laps_min_fields
  stddev: laps_stddev_fields
  stddev_pop: laps_stddev_pop_fields
  stddev_samp: laps_stddev_samp_fields
  sum: laps_sum_fields
  var_pop: laps_var_pop_fields
  var_samp: laps_var_samp_fields
  variance: laps_variance_fields
}

"""
order by aggregate values of table "laps"
"""
input laps_aggregate_order_by {
  avg: laps_avg_order_by
  count: order_by
  max: laps_max_order_by
  min: laps_min_order_by
  stddev: laps_stddev_order_by
  stddev_pop: laps_stddev_pop_order_by
  stddev_samp: laps_stddev_samp_order_by
  sum: laps_sum_order_by
  var_pop: laps_var_pop_order_by
  var_samp: laps_var_samp_order_by
  variance: laps_variance_order_by
}

"""
input type for inserting array relation for remote table "laps"
"""
input laps_arr_rel_insert_input {
  data: [laps_insert_input!]!

  """
  upsert condition
  """
  on_conflict: laps_on_conflict
}

"""
aggregate avg on columns
"""
type laps_avg_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by avg() on columns of table "laps"
"""
input laps_avg_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
Boolean expression to filter rows from the table "laps". All fields are combined with a logical 'AND'.
"""
input laps_bool_exp {
  _and: [laps_bool_exp!]
  _not: laps_bool_exp
  _or: [laps_bool_exp!]
  compound: tyre_compounds_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  fresh_tyre: Boolean_comparison_exp
  id: String_comparison_exp
  is_accurate: Boolean_comparison_exp
  is_personal_best: Boolean_comparison_exp
  lap_number: Int_comparison_exp
  lap_time: bigint_comparison_exp
  pitin_time: bigint_comparison_exp
  pitout_time: bigint_comparison_exp
  sector1: bigint_comparison_exp
  sector1_ts: bigint_comparison_exp
  sector2: bigint_comparison_exp
  sector2_ts: bigint_comparison_exp
  sector3: bigint_comparison_exp
  sector3_ts: bigint_comparison_exp
  session_time: bigint_comparison_exp
  speed_trap_fastest_lap: numeric_comparison_exp
  speed_trap_sector1: numeric_comparison_exp
  speed_trap_sector2: numeric_comparison_exp
  speed_trap_straight: numeric_comparison_exp
  stint: Int_comparison_exp
  tyre_life: Int_comparison_exp
}

"""
unique or primary key constraints on table "laps"
"""
enum laps_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  laps_pkey
}

"""
input type for incrementing numeric columns in table "laps"
"""
input laps_inc_input {
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
input type for inserting data into table "laps"
"""
input laps_insert_input {
  compound: tyre_compounds
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate max on columns
"""
type laps_max_fields {
  compound: tyre_compounds
  driver_session_id: String
  id: String
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by max() on columns of table "laps"
"""
input laps_max_order_by {
  compound: order_by
  driver_session_id: order_by
  id: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate min on columns
"""
type laps_min_fields {
  compound: tyre_compounds
  driver_session_id: String
  id: String
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by min() on columns of table "laps"
"""
input laps_min_order_by {
  compound: order_by
  driver_session_id: order_by
  id: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
response of any mutation on the table "laps"
"""
type laps_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [laps!]!
}

"""
on_conflict condition type for table "laps"
"""
input laps_on_conflict {
  constraint: laps_constraint!
  update_columns: [laps_update_column!]! = []
  where: laps_bool_exp
}

"""
Ordering options when selecting data from "laps".
"""
input laps_order_by {
  compound: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  fresh_tyre: order_by
  id: order_by
  is_accurate: order_by
  is_personal_best: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
primary key columns input for table: laps
"""
input laps_pk_columns_input {
  id: String!
}

"""
select columns of table "laps"
"""
enum laps_select_column {
  """
  column name
  """
  compound

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  id

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best

  """
  column name
  """
  lap_number

  """
  column name
  """
  lap_time

  """
  column name
  """
  pitin_time

  """
  column name
  """
  pitout_time

  """
  column name
  """
  sector1

  """
  column name
  """
  sector1_ts

  """
  column name
  """
  sector2

  """
  column name
  """
  sector2_ts

  """
  column name
  """
  sector3

  """
  column name
  """
  sector3_ts

  """
  column name
  """
  session_time

  """
  column name
  """
  speed_trap_fastest_lap

  """
  column name
  """
  speed_trap_sector1

  """
  column name
  """
  speed_trap_sector2

  """
  column name
  """
  speed_trap_straight

  """
  column name
  """
  stint

  """
  column name
  """
  tyre_life
}

"""
select "laps_aggregate_bool_exp_bool_and_arguments_columns" columns of table "laps"
"""
enum laps_select_column_laps_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best
}

"""
select "laps_aggregate_bool_exp_bool_or_arguments_columns" columns of table "laps"
"""
enum laps_select_column_laps_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best
}

"""
input type for updating data in table "laps"
"""
input laps_set_input {
  compound: tyre_compounds
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate stddev on columns
"""
type laps_stddev_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev() on columns of table "laps"
"""
input laps_stddev_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate stddev_pop on columns
"""
type laps_stddev_pop_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev_pop() on columns of table "laps"
"""
input laps_stddev_pop_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate stddev_samp on columns
"""
type laps_stddev_samp_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev_samp() on columns of table "laps"
"""
input laps_stddev_samp_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
Streaming cursor of the table "laps"
"""
input laps_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: laps_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input laps_stream_cursor_value_input {
  compound: tyre_compounds
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate sum on columns
"""
type laps_sum_fields {
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by sum() on columns of table "laps"
"""
input laps_sum_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
update columns of table "laps"
"""
enum laps_update_column {
  """
  column name
  """
  compound

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  id

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best

  """
  column name
  """
  lap_number

  """
  column name
  """
  lap_time

  """
  column name
  """
  pitin_time

  """
  column name
  """
  pitout_time

  """
  column name
  """
  sector1

  """
  column name
  """
  sector1_ts

  """
  column name
  """
  sector2

  """
  column name
  """
  sector2_ts

  """
  column name
  """
  sector3

  """
  column name
  """
  sector3_ts

  """
  column name
  """
  session_time

  """
  column name
  """
  speed_trap_fastest_lap

  """
  column name
  """
  speed_trap_sector1

  """
  column name
  """
  speed_trap_sector2

  """
  column name
  """
  speed_trap_straight

  """
  column name
  """
  stint

  """
  column name
  """
  tyre_life
}

input laps_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: laps_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: laps_set_input

  """
  filter the rows which have to be updated
  """
  where: laps_bool_exp!
}

"""
aggregate var_pop on columns
"""
type laps_var_pop_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by var_pop() on columns of table "laps"
"""
input laps_var_pop_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate var_samp on columns
"""
type laps_var_samp_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by var_samp() on columns of table "laps"
"""
input laps_var_samp_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate variance on columns
"""
type laps_variance_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by variance() on columns of table "laps"
"""
input laps_variance_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "circuits"
  """
  delete_circuits(
    """
    filter the rows which have to be deleted
    """
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  delete single row from the table: "circuits"
  """
  delete_circuits_by_pk(id: String!): circuits

  """
  delete data from the table: "constructor_standings"
  """
  delete_constructor_standings(
    """
    filter the rows which have to be deleted
    """
    where: constructor_standings_bool_exp!
  ): constructor_standings_mutation_response

  """
  delete single row from the table: "constructor_standings"
  """
  delete_constructor_standings_by_pk(id: String!): constructor_standings

  """
  delete data from the table: "constructors"
  """
  delete_constructors(
    """
    filter the rows which have to be deleted
    """
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  delete single row from the table: "constructors"
  """
  delete_constructors_by_pk(id: String!): constructors

  """
  delete data from the table: "driver_sessions"
  """
  delete_driver_sessions(
    """
    filter the rows which have to be deleted
    """
    where: driver_sessions_bool_exp!
  ): driver_sessions_mutation_response

  """
  delete single row from the table: "driver_sessions"
  """
  delete_driver_sessions_by_pk(id: String!): driver_sessions

  """
  delete data from the table: "driver_standings"
  """
  delete_driver_standings(
    """
    filter the rows which have to be deleted
    """
    where: driver_standings_bool_exp!
  ): driver_standings_mutation_response

  """
  delete single row from the table: "driver_standings"
  """
  delete_driver_standings_by_pk(id: String!): driver_standings

  """
  delete data from the table: "drivers"
  """
  delete_drivers(
    """
    filter the rows which have to be deleted
    """
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  delete single row from the table: "drivers"
  """
  delete_drivers_by_pk(id: String!): drivers

  """
  delete data from the table: "events"
  """
  delete_events(
    """
    filter the rows which have to be deleted
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete single row from the table: "events"
  """
  delete_events_by_pk(id: String!): events

  """
  delete data from the table: "laps"
  """
  delete_laps(
    """
    filter the rows which have to be deleted
    """
    where: laps_bool_exp!
  ): laps_mutation_response

  """
  delete single row from the table: "laps"
  """
  delete_laps_by_pk(id: String!): laps

  """
  delete data from the table: "race_control_messages"
  """
  delete_race_control_messages(
    """
    filter the rows which have to be deleted
    """
    where: race_control_messages_bool_exp!
  ): race_control_messages_mutation_response

  """
  delete single row from the table: "race_control_messages"
  """
  delete_race_control_messages_by_pk(id: String!): race_control_messages

  """
  delete data from the table: "results"
  """
  delete_results(
    """
    filter the rows which have to be deleted
    """
    where: results_bool_exp!
  ): results_mutation_response

  """
  delete single row from the table: "results"
  """
  delete_results_by_pk(id: String!): results

  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    """
    filter the rows which have to be deleted
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(id: String!): sessions

  """
  delete data from the table: "telemetry"
  """
  delete_telemetry(
    """
    filter the rows which have to be deleted
    """
    where: telemetry_bool_exp!
  ): telemetry_mutation_response

  """
  delete single row from the table: "telemetry"
  """
  delete_telemetry_by_pk(id: String!): telemetry

  """
  delete data from the table: "track_status"
  """
  delete_track_status(
    """
    filter the rows which have to be deleted
    """
    where: track_status_bool_exp!
  ): track_status_mutation_response

  """
  delete single row from the table: "track_status"
  """
  delete_track_status_by_pk(id: String!): track_status

  """
  delete data from the table: "weather_data"
  """
  delete_weather_data(
    """
    filter the rows which have to be deleted
    """
    where: weather_data_bool_exp!
  ): weather_data_mutation_response

  """
  delete single row from the table: "weather_data"
  """
  delete_weather_data_by_pk(id: String!): weather_data

  """
  insert data into the table: "circuits"
  """
  insert_circuits(
    """
    the rows to be inserted
    """
    objects: [circuits_insert_input!]!

    """
    upsert condition
    """
    on_conflict: circuits_on_conflict
  ): circuits_mutation_response

  """
  insert a single row into the table: "circuits"
  """
  insert_circuits_one(
    """
    the row to be inserted
    """
    object: circuits_insert_input!

    """
    upsert condition
    """
    on_conflict: circuits_on_conflict
  ): circuits

  """
  insert data into the table: "constructor_standings"
  """
  insert_constructor_standings(
    """
    the rows to be inserted
    """
    objects: [constructor_standings_insert_input!]!

    """
    upsert condition
    """
    on_conflict: constructor_standings_on_conflict
  ): constructor_standings_mutation_response

  """
  insert a single row into the table: "constructor_standings"
  """
  insert_constructor_standings_one(
    """
    the row to be inserted
    """
    object: constructor_standings_insert_input!

    """
    upsert condition
    """
    on_conflict: constructor_standings_on_conflict
  ): constructor_standings

  """
  insert data into the table: "constructors"
  """
  insert_constructors(
    """
    the rows to be inserted
    """
    objects: [constructors_insert_input!]!

    """
    upsert condition
    """
    on_conflict: constructors_on_conflict
  ): constructors_mutation_response

  """
  insert a single row into the table: "constructors"
  """
  insert_constructors_one(
    """
    the row to be inserted
    """
    object: constructors_insert_input!

    """
    upsert condition
    """
    on_conflict: constructors_on_conflict
  ): constructors

  """
  insert data into the table: "driver_sessions"
  """
  insert_driver_sessions(
    """
    the rows to be inserted
    """
    objects: [driver_sessions_insert_input!]!

    """
    upsert condition
    """
    on_conflict: driver_sessions_on_conflict
  ): driver_sessions_mutation_response

  """
  insert a single row into the table: "driver_sessions"
  """
  insert_driver_sessions_one(
    """
    the row to be inserted
    """
    object: driver_sessions_insert_input!

    """
    upsert condition
    """
    on_conflict: driver_sessions_on_conflict
  ): driver_sessions

  """
  insert data into the table: "driver_standings"
  """
  insert_driver_standings(
    """
    the rows to be inserted
    """
    objects: [driver_standings_insert_input!]!

    """
    upsert condition
    """
    on_conflict: driver_standings_on_conflict
  ): driver_standings_mutation_response

  """
  insert a single row into the table: "driver_standings"
  """
  insert_driver_standings_one(
    """
    the row to be inserted
    """
    object: driver_standings_insert_input!

    """
    upsert condition
    """
    on_conflict: driver_standings_on_conflict
  ): driver_standings

  """
  insert data into the table: "drivers"
  """
  insert_drivers(
    """
    the rows to be inserted
    """
    objects: [drivers_insert_input!]!

    """
    upsert condition
    """
    on_conflict: drivers_on_conflict
  ): drivers_mutation_response

  """
  insert a single row into the table: "drivers"
  """
  insert_drivers_one(
    """
    the row to be inserted
    """
    object: drivers_insert_input!

    """
    upsert condition
    """
    on_conflict: drivers_on_conflict
  ): drivers

  """
  insert data into the table: "events"
  """
  insert_events(
    """
    the rows to be inserted
    """
    objects: [events_insert_input!]!

    """
    upsert condition
    """
    on_conflict: events_on_conflict
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """
    the row to be inserted
    """
    object: events_insert_input!

    """
    upsert condition
    """
    on_conflict: events_on_conflict
  ): events

  """
  insert data into the table: "laps"
  """
  insert_laps(
    """
    the rows to be inserted
    """
    objects: [laps_insert_input!]!

    """
    upsert condition
    """
    on_conflict: laps_on_conflict
  ): laps_mutation_response

  """
  insert a single row into the table: "laps"
  """
  insert_laps_one(
    """
    the row to be inserted
    """
    object: laps_insert_input!

    """
    upsert condition
    """
    on_conflict: laps_on_conflict
  ): laps

  """
  insert data into the table: "race_control_messages"
  """
  insert_race_control_messages(
    """
    the rows to be inserted
    """
    objects: [race_control_messages_insert_input!]!

    """
    upsert condition
    """
    on_conflict: race_control_messages_on_conflict
  ): race_control_messages_mutation_response

  """
  insert a single row into the table: "race_control_messages"
  """
  insert_race_control_messages_one(
    """
    the row to be inserted
    """
    object: race_control_messages_insert_input!

    """
    upsert condition
    """
    on_conflict: race_control_messages_on_conflict
  ): race_control_messages

  """
  insert data into the table: "results"
  """
  insert_results(
    """
    the rows to be inserted
    """
    objects: [results_insert_input!]!

    """
    upsert condition
    """
    on_conflict: results_on_conflict
  ): results_mutation_response

  """
  insert a single row into the table: "results"
  """
  insert_results_one(
    """
    the row to be inserted
    """
    object: results_insert_input!

    """
    upsert condition
    """
    on_conflict: results_on_conflict
  ): results

  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    """
    the rows to be inserted
    """
    objects: [sessions_insert_input!]!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    """
    the row to be inserted
    """
    object: sessions_insert_input!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "telemetry"
  """
  insert_telemetry(
    """
    the rows to be inserted
    """
    objects: [telemetry_insert_input!]!

    """
    upsert condition
    """
    on_conflict: telemetry_on_conflict
  ): telemetry_mutation_response

  """
  insert a single row into the table: "telemetry"
  """
  insert_telemetry_one(
    """
    the row to be inserted
    """
    object: telemetry_insert_input!

    """
    upsert condition
    """
    on_conflict: telemetry_on_conflict
  ): telemetry

  """
  insert data into the table: "track_status"
  """
  insert_track_status(
    """
    the rows to be inserted
    """
    objects: [track_status_insert_input!]!

    """
    upsert condition
    """
    on_conflict: track_status_on_conflict
  ): track_status_mutation_response

  """
  insert a single row into the table: "track_status"
  """
  insert_track_status_one(
    """
    the row to be inserted
    """
    object: track_status_insert_input!

    """
    upsert condition
    """
    on_conflict: track_status_on_conflict
  ): track_status

  """
  insert data into the table: "weather_data"
  """
  insert_weather_data(
    """
    the rows to be inserted
    """
    objects: [weather_data_insert_input!]!

    """
    upsert condition
    """
    on_conflict: weather_data_on_conflict
  ): weather_data_mutation_response

  """
  insert a single row into the table: "weather_data"
  """
  insert_weather_data_one(
    """
    the row to be inserted
    """
    object: weather_data_insert_input!

    """
    upsert condition
    """
    on_conflict: weather_data_on_conflict
  ): weather_data

  """
  update data of the table: "circuits"
  """
  update_circuits(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: circuits_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: circuits_set_input

    """
    filter the rows which have to be updated
    """
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  update single row of the table: "circuits"
  """
  update_circuits_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: circuits_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: circuits_set_input
    pk_columns: circuits_pk_columns_input!
  ): circuits

  """
  update multiples rows of table: "circuits"
  """
  update_circuits_many(
    """
    updates to execute, in order
    """
    updates: [circuits_updates!]!
  ): [circuits_mutation_response]

  """
  update data of the table: "constructor_standings"
  """
  update_constructor_standings(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructor_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructor_standings_set_input

    """
    filter the rows which have to be updated
    """
    where: constructor_standings_bool_exp!
  ): constructor_standings_mutation_response

  """
  update single row of the table: "constructor_standings"
  """
  update_constructor_standings_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructor_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructor_standings_set_input
    pk_columns: constructor_standings_pk_columns_input!
  ): constructor_standings

  """
  update multiples rows of table: "constructor_standings"
  """
  update_constructor_standings_many(
    """
    updates to execute, in order
    """
    updates: [constructor_standings_updates!]!
  ): [constructor_standings_mutation_response]

  """
  update data of the table: "constructors"
  """
  update_constructors(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructors_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructors_set_input

    """
    filter the rows which have to be updated
    """
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  update single row of the table: "constructors"
  """
  update_constructors_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructors_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructors_set_input
    pk_columns: constructors_pk_columns_input!
  ): constructors

  """
  update multiples rows of table: "constructors"
  """
  update_constructors_many(
    """
    updates to execute, in order
    """
    updates: [constructors_updates!]!
  ): [constructors_mutation_response]

  """
  update data of the table: "driver_sessions"
  """
  update_driver_sessions(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_sessions_set_input

    """
    filter the rows which have to be updated
    """
    where: driver_sessions_bool_exp!
  ): driver_sessions_mutation_response

  """
  update single row of the table: "driver_sessions"
  """
  update_driver_sessions_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_sessions_set_input
    pk_columns: driver_sessions_pk_columns_input!
  ): driver_sessions

  """
  update multiples rows of table: "driver_sessions"
  """
  update_driver_sessions_many(
    """
    updates to execute, in order
    """
    updates: [driver_sessions_updates!]!
  ): [driver_sessions_mutation_response]

  """
  update data of the table: "driver_standings"
  """
  update_driver_standings(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: driver_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_standings_set_input

    """
    filter the rows which have to be updated
    """
    where: driver_standings_bool_exp!
  ): driver_standings_mutation_response

  """
  update single row of the table: "driver_standings"
  """
  update_driver_standings_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: driver_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_standings_set_input
    pk_columns: driver_standings_pk_columns_input!
  ): driver_standings

  """
  update multiples rows of table: "driver_standings"
  """
  update_driver_standings_many(
    """
    updates to execute, in order
    """
    updates: [driver_standings_updates!]!
  ): [driver_standings_mutation_response]

  """
  update data of the table: "drivers"
  """
  update_drivers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: drivers_set_input

    """
    filter the rows which have to be updated
    """
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  update single row of the table: "drivers"
  """
  update_drivers_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: drivers_set_input
    pk_columns: drivers_pk_columns_input!
  ): drivers

  """
  update multiples rows of table: "drivers"
  """
  update_drivers_many(
    """
    updates to execute, in order
    """
    updates: [drivers_updates!]!
  ): [drivers_mutation_response]

  """
  update data of the table: "events"
  """
  update_events(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: events_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: events_set_input

    """
    filter the rows which have to be updated
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  update single row of the table: "events"
  """
  update_events_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: events_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: events_set_input
    pk_columns: events_pk_columns_input!
  ): events

  """
  update multiples rows of table: "events"
  """
  update_events_many(
    """
    updates to execute, in order
    """
    updates: [events_updates!]!
  ): [events_mutation_response]

  """
  update data of the table: "laps"
  """
  update_laps(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: laps_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: laps_set_input

    """
    filter the rows which have to be updated
    """
    where: laps_bool_exp!
  ): laps_mutation_response

  """
  update single row of the table: "laps"
  """
  update_laps_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: laps_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: laps_set_input
    pk_columns: laps_pk_columns_input!
  ): laps

  """
  update multiples rows of table: "laps"
  """
  update_laps_many(
    """
    updates to execute, in order
    """
    updates: [laps_updates!]!
  ): [laps_mutation_response]

  """
  update data of the table: "race_control_messages"
  """
  update_race_control_messages(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: race_control_messages_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: race_control_messages_set_input

    """
    filter the rows which have to be updated
    """
    where: race_control_messages_bool_exp!
  ): race_control_messages_mutation_response

  """
  update single row of the table: "race_control_messages"
  """
  update_race_control_messages_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: race_control_messages_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: race_control_messages_set_input
    pk_columns: race_control_messages_pk_columns_input!
  ): race_control_messages

  """
  update multiples rows of table: "race_control_messages"
  """
  update_race_control_messages_many(
    """
    updates to execute, in order
    """
    updates: [race_control_messages_updates!]!
  ): [race_control_messages_mutation_response]

  """
  update data of the table: "results"
  """
  update_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: results_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: results_set_input

    """
    filter the rows which have to be updated
    """
    where: results_bool_exp!
  ): results_mutation_response

  """
  update single row of the table: "results"
  """
  update_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: results_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: results_set_input
    pk_columns: results_pk_columns_input!
  ): results

  """
  update multiples rows of table: "results"
  """
  update_results_many(
    """
    updates to execute, in order
    """
    updates: [results_updates!]!
  ): [results_mutation_response]

  """
  update data of the table: "sessions"
  """
  update_sessions(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: sessions_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input

    """
    filter the rows which have to be updated
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: sessions_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    """
    updates to execute, in order
    """
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]

  """
  update data of the table: "telemetry"
  """
  update_telemetry(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: telemetry_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: telemetry_set_input

    """
    filter the rows which have to be updated
    """
    where: telemetry_bool_exp!
  ): telemetry_mutation_response

  """
  update single row of the table: "telemetry"
  """
  update_telemetry_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: telemetry_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: telemetry_set_input
    pk_columns: telemetry_pk_columns_input!
  ): telemetry

  """
  update multiples rows of table: "telemetry"
  """
  update_telemetry_many(
    """
    updates to execute, in order
    """
    updates: [telemetry_updates!]!
  ): [telemetry_mutation_response]

  """
  update data of the table: "track_status"
  """
  update_track_status(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: track_status_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: track_status_set_input

    """
    filter the rows which have to be updated
    """
    where: track_status_bool_exp!
  ): track_status_mutation_response

  """
  update single row of the table: "track_status"
  """
  update_track_status_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: track_status_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: track_status_set_input
    pk_columns: track_status_pk_columns_input!
  ): track_status

  """
  update multiples rows of table: "track_status"
  """
  update_track_status_many(
    """
    updates to execute, in order
    """
    updates: [track_status_updates!]!
  ): [track_status_mutation_response]

  """
  update data of the table: "weather_data"
  """
  update_weather_data(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: weather_data_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: weather_data_set_input

    """
    filter the rows which have to be updated
    """
    where: weather_data_bool_exp!
  ): weather_data_mutation_response

  """
  update single row of the table: "weather_data"
  """
  update_weather_data_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: weather_data_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: weather_data_set_input
    pk_columns: weather_data_pk_columns_input!
  ): weather_data

  """
  update multiples rows of table: "weather_data"
  """
  update_weather_data_many(
    """
    updates to execute, in order
    """
    updates: [weather_data_updates!]!
  ): [weather_data_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): circuits_aggregate!

  """
  fetch data from the table: "circuits" using primary key columns
  """
  circuits_by_pk(id: String!): circuits

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  fetch data from the table: "constructor_standings" using primary key columns
  """
  constructor_standings_by_pk(id: String!): constructor_standings

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): constructors_aggregate!

  """
  fetch data from the table: "constructors" using primary key columns
  """
  constructors_by_pk(id: String!): constructors

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  fetch data from the table: "driver_sessions" using primary key columns
  """
  driver_sessions_by_pk(id: String!): driver_sessions

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!

  """
  fetch data from the table: "driver_standings" using primary key columns
  """
  driver_standings_by_pk(id: String!): driver_standings

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): drivers_aggregate!

  """
  fetch data from the table: "drivers" using primary key columns
  """
  drivers_by_pk(id: String!): drivers

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  fetch data from the table: "events" using primary key columns
  """
  events_by_pk(id: String!): events

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  fetch data from the table: "laps" using primary key columns
  """
  laps_by_pk(id: String!): laps

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!

  """
  fetch data from the table: "race_control_messages" using primary key columns
  """
  race_control_messages_by_pk(id: String!): race_control_messages

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  fetch data from the table: "results" using primary key columns
  """
  results_by_pk(id: String!): results

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table: "telemetry"
  """
  telemetry(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch aggregated fields from the table: "telemetry"
  """
  telemetry_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!

  """
  fetch data from the table: "telemetry" using primary key columns
  """
  telemetry_by_pk(id: String!): telemetry

  """
  fetch data from the table: "track_status"
  """
  track_status(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  fetch aggregated fields from the table: "track_status"
  """
  track_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  fetch data from the table: "track_status" using primary key columns
  """
  track_status_by_pk(id: String!): track_status

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!

  """
  fetch data from the table: "weather_data" using primary key columns
  """
  weather_data_by_pk(id: String!): weather_data
}

"""
columns and relationships of "race_control_messages"
"""
type race_control_messages {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String!
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric

  """
  An object relationship
  """
  session: sessions
  session_id: String
  status: String
  time: String
}

"""
aggregated selection of "race_control_messages"
"""
type race_control_messages_aggregate {
  aggregate: race_control_messages_aggregate_fields
  nodes: [race_control_messages!]!
}

input race_control_messages_aggregate_bool_exp {
  count: race_control_messages_aggregate_bool_exp_count
}

input race_control_messages_aggregate_bool_exp_count {
  arguments: [race_control_messages_select_column!]
  distinct: Boolean
  filter: race_control_messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "race_control_messages"
"""
type race_control_messages_aggregate_fields {
  avg: race_control_messages_avg_fields
  count(
    columns: [race_control_messages_select_column!]
    distinct: Boolean
  ): Int!
  max: race_control_messages_max_fields
  min: race_control_messages_min_fields
  stddev: race_control_messages_stddev_fields
  stddev_pop: race_control_messages_stddev_pop_fields
  stddev_samp: race_control_messages_stddev_samp_fields
  sum: race_control_messages_sum_fields
  var_pop: race_control_messages_var_pop_fields
  var_samp: race_control_messages_var_samp_fields
  variance: race_control_messages_variance_fields
}

"""
order by aggregate values of table "race_control_messages"
"""
input race_control_messages_aggregate_order_by {
  avg: race_control_messages_avg_order_by
  count: order_by
  max: race_control_messages_max_order_by
  min: race_control_messages_min_order_by
  stddev: race_control_messages_stddev_order_by
  stddev_pop: race_control_messages_stddev_pop_order_by
  stddev_samp: race_control_messages_stddev_samp_order_by
  sum: race_control_messages_sum_order_by
  var_pop: race_control_messages_var_pop_order_by
  var_samp: race_control_messages_var_samp_order_by
  variance: race_control_messages_variance_order_by
}

"""
input type for inserting array relation for remote table "race_control_messages"
"""
input race_control_messages_arr_rel_insert_input {
  data: [race_control_messages_insert_input!]!

  """
  upsert condition
  """
  on_conflict: race_control_messages_on_conflict
}

"""
aggregate avg on columns
"""
type race_control_messages_avg_fields {
  sector: Float
}

"""
order by avg() on columns of table "race_control_messages"
"""
input race_control_messages_avg_order_by {
  sector: order_by
}

"""
Boolean expression to filter rows from the table "race_control_messages". All fields are combined with a logical 'AND'.
"""
input race_control_messages_bool_exp {
  _and: [race_control_messages_bool_exp!]
  _not: race_control_messages_bool_exp
  _or: [race_control_messages_bool_exp!]
  category: race_control_messages_categories_comparison_exp
  flag: race_control_messages_flags_comparison_exp
  id: String_comparison_exp
  message: String_comparison_exp
  racing_number: String_comparison_exp
  scope: race_control_messages_scopes_comparison_exp
  sector: numeric_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  status: String_comparison_exp
  time: String_comparison_exp
}

scalar race_control_messages_categories

"""
Boolean expression to compare columns of type "race_control_messages_categories". All fields are combined with logical 'AND'.
"""
input race_control_messages_categories_comparison_exp {
  _eq: race_control_messages_categories
  _gt: race_control_messages_categories
  _gte: race_control_messages_categories
  _in: [race_control_messages_categories!]
  _is_null: Boolean
  _lt: race_control_messages_categories
  _lte: race_control_messages_categories
  _neq: race_control_messages_categories
  _nin: [race_control_messages_categories!]
}

"""
unique or primary key constraints on table "race_control_messages"
"""
enum race_control_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  race_control_messages_pkey
}

scalar race_control_messages_flags

"""
Boolean expression to compare columns of type "race_control_messages_flags". All fields are combined with logical 'AND'.
"""
input race_control_messages_flags_comparison_exp {
  _eq: race_control_messages_flags
  _gt: race_control_messages_flags
  _gte: race_control_messages_flags
  _in: [race_control_messages_flags!]
  _is_null: Boolean
  _lt: race_control_messages_flags
  _lte: race_control_messages_flags
  _neq: race_control_messages_flags
  _nin: [race_control_messages_flags!]
}

"""
input type for incrementing numeric columns in table "race_control_messages"
"""
input race_control_messages_inc_input {
  sector: numeric
}

"""
input type for inserting data into table "race_control_messages"
"""
input race_control_messages_insert_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session: sessions_obj_rel_insert_input
  session_id: String
  status: String
  time: String
}

"""
aggregate max on columns
"""
type race_control_messages_max_fields {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
order by max() on columns of table "race_control_messages"
"""
input race_control_messages_max_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
aggregate min on columns
"""
type race_control_messages_min_fields {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
order by min() on columns of table "race_control_messages"
"""
input race_control_messages_min_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
response of any mutation on the table "race_control_messages"
"""
type race_control_messages_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [race_control_messages!]!
}

"""
on_conflict condition type for table "race_control_messages"
"""
input race_control_messages_on_conflict {
  constraint: race_control_messages_constraint!
  update_columns: [race_control_messages_update_column!]! = []
  where: race_control_messages_bool_exp
}

"""
Ordering options when selecting data from "race_control_messages".
"""
input race_control_messages_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session: sessions_order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
primary key columns input for table: race_control_messages
"""
input race_control_messages_pk_columns_input {
  id: String!
}

scalar race_control_messages_scopes

"""
Boolean expression to compare columns of type "race_control_messages_scopes". All fields are combined with logical 'AND'.
"""
input race_control_messages_scopes_comparison_exp {
  _eq: race_control_messages_scopes
  _gt: race_control_messages_scopes
  _gte: race_control_messages_scopes
  _in: [race_control_messages_scopes!]
  _is_null: Boolean
  _lt: race_control_messages_scopes
  _lte: race_control_messages_scopes
  _neq: race_control_messages_scopes
  _nin: [race_control_messages_scopes!]
}

"""
select columns of table "race_control_messages"
"""
enum race_control_messages_select_column {
  """
  column name
  """
  category

  """
  column name
  """
  flag

  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  racing_number

  """
  column name
  """
  scope

  """
  column name
  """
  sector

  """
  column name
  """
  session_id

  """
  column name
  """
  status

  """
  column name
  """
  time
}

"""
input type for updating data in table "race_control_messages"
"""
input race_control_messages_set_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
aggregate stddev on columns
"""
type race_control_messages_stddev_fields {
  sector: Float
}

"""
order by stddev() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_order_by {
  sector: order_by
}

"""
aggregate stddev_pop on columns
"""
type race_control_messages_stddev_pop_fields {
  sector: Float
}

"""
order by stddev_pop() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_pop_order_by {
  sector: order_by
}

"""
aggregate stddev_samp on columns
"""
type race_control_messages_stddev_samp_fields {
  sector: Float
}

"""
order by stddev_samp() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_samp_order_by {
  sector: order_by
}

"""
Streaming cursor of the table "race_control_messages"
"""
input race_control_messages_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: race_control_messages_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input race_control_messages_stream_cursor_value_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
aggregate sum on columns
"""
type race_control_messages_sum_fields {
  sector: numeric
}

"""
order by sum() on columns of table "race_control_messages"
"""
input race_control_messages_sum_order_by {
  sector: order_by
}

"""
update columns of table "race_control_messages"
"""
enum race_control_messages_update_column {
  """
  column name
  """
  category

  """
  column name
  """
  flag

  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  racing_number

  """
  column name
  """
  scope

  """
  column name
  """
  sector

  """
  column name
  """
  session_id

  """
  column name
  """
  status

  """
  column name
  """
  time
}

input race_control_messages_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: race_control_messages_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: race_control_messages_set_input

  """
  filter the rows which have to be updated
  """
  where: race_control_messages_bool_exp!
}

"""
aggregate var_pop on columns
"""
type race_control_messages_var_pop_fields {
  sector: Float
}

"""
order by var_pop() on columns of table "race_control_messages"
"""
input race_control_messages_var_pop_order_by {
  sector: order_by
}

"""
aggregate var_samp on columns
"""
type race_control_messages_var_samp_fields {
  sector: Float
}

"""
order by var_samp() on columns of table "race_control_messages"
"""
input race_control_messages_var_samp_order_by {
  sector: order_by
}

"""
aggregate variance on columns
"""
type race_control_messages_variance_fields {
  sector: Float
}

"""
order by variance() on columns of table "race_control_messages"
"""
input race_control_messages_variance_order_by {
  sector: order_by
}

"""
columns and relationships of "results"
"""
type results {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String!
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregated selection of "results"
"""
type results_aggregate {
  aggregate: results_aggregate_fields
  nodes: [results!]!
}

input results_aggregate_bool_exp {
  count: results_aggregate_bool_exp_count
}

input results_aggregate_bool_exp_count {
  arguments: [results_select_column!]
  distinct: Boolean
  filter: results_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "results"
"""
type results_aggregate_fields {
  avg: results_avg_fields
  count(columns: [results_select_column!], distinct: Boolean): Int!
  max: results_max_fields
  min: results_min_fields
  stddev: results_stddev_fields
  stddev_pop: results_stddev_pop_fields
  stddev_samp: results_stddev_samp_fields
  sum: results_sum_fields
  var_pop: results_var_pop_fields
  var_samp: results_var_samp_fields
  variance: results_variance_fields
}

"""
order by aggregate values of table "results"
"""
input results_aggregate_order_by {
  avg: results_avg_order_by
  count: order_by
  max: results_max_order_by
  min: results_min_order_by
  stddev: results_stddev_order_by
  stddev_pop: results_stddev_pop_order_by
  stddev_samp: results_stddev_samp_order_by
  sum: results_sum_order_by
  var_pop: results_var_pop_order_by
  var_samp: results_var_samp_order_by
  variance: results_variance_order_by
}

"""
input type for inserting array relation for remote table "results"
"""
input results_arr_rel_insert_input {
  data: [results_insert_input!]!

  """
  upsert condition
  """
  on_conflict: results_on_conflict
}

"""
aggregate avg on columns
"""
type results_avg_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by avg() on columns of table "results"
"""
input results_avg_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
Boolean expression to filter rows from the table "results". All fields are combined with a logical 'AND'.
"""
input results_bool_exp {
  _and: [results_bool_exp!]
  _not: results_bool_exp
  _or: [results_bool_exp!]
  classified_position: String_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  finishing_position: Int_comparison_exp
  grid_position: Int_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  q1_time: bigint_comparison_exp
  q2_time: bigint_comparison_exp
  q3_time: bigint_comparison_exp
  status: String_comparison_exp
  total_race_time: bigint_comparison_exp
}

"""
unique or primary key constraints on table "results"
"""
enum results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  results_pkey
}

"""
input type for incrementing numeric columns in table "results"
"""
input results_inc_input {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  total_race_time: bigint
}

"""
input type for inserting data into table "results"
"""
input results_insert_input {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate max on columns
"""
type results_max_fields {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
order by max() on columns of table "results"
"""
input results_max_order_by {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: order_by
  driver_session_id: order_by

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
aggregate min on columns
"""
type results_min_fields {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
order by min() on columns of table "results"
"""
input results_min_order_by {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: order_by
  driver_session_id: order_by

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
response of any mutation on the table "results"
"""
type results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [results!]!
}

"""
on_conflict condition type for table "results"
"""
input results_on_conflict {
  constraint: results_constraint!
  update_columns: [results_update_column!]! = []
  where: results_bool_exp
}

"""
Ordering options when selecting data from "results".
"""
input results_order_by {
  classified_position: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
primary key columns input for table: results
"""
input results_pk_columns_input {
  id: String!
}

"""
select columns of table "results"
"""
enum results_select_column {
  """
  column name
  """
  classified_position

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  finishing_position

  """
  column name
  """
  grid_position

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  q1_time

  """
  column name
  """
  q2_time

  """
  column name
  """
  q3_time

  """
  column name
  """
  status

  """
  column name
  """
  total_race_time
}

"""
input type for updating data in table "results"
"""
input results_set_input {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate stddev on columns
"""
type results_stddev_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev() on columns of table "results"
"""
input results_stddev_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate stddev_pop on columns
"""
type results_stddev_pop_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev_pop() on columns of table "results"
"""
input results_stddev_pop_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate stddev_samp on columns
"""
type results_stddev_samp_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev_samp() on columns of table "results"
"""
input results_stddev_samp_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
Streaming cursor of the table "results"
"""
input results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: results_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input results_stream_cursor_value_input {
  """
  This is either an integer value if the driver is officially classified or one of “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate sum on columns
"""
type results_sum_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Int
  grid_position: Int
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  total_race_time: bigint
}

"""
order by sum() on columns of table "results"
"""
input results_sum_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
update columns of table "results"
"""
enum results_update_column {
  """
  column name
  """
  classified_position

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  finishing_position

  """
  column name
  """
  grid_position

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  q1_time

  """
  column name
  """
  q2_time

  """
  column name
  """
  q3_time

  """
  column name
  """
  status

  """
  column name
  """
  total_race_time
}

input results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: results_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: results_set_input

  """
  filter the rows which have to be updated
  """
  where: results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type results_var_pop_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by var_pop() on columns of table "results"
"""
input results_var_pop_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate var_samp on columns
"""
type results_var_samp_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by var_samp() on columns of table "results"
"""
input results_var_samp_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate variance on columns
"""
type results_variance_fields {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by variance() on columns of table "results"
"""
input results_variance_order_by {
  """
  The drivers finishing position (values only given if session is ‘Race’, ‘Qualifying’, ‘Sprint Shootout’, ‘Sprint’, or ‘Sprint Qualifying’
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

scalar session_name_choices

"""
Boolean expression to compare columns of type "session_name_choices". All fields are combined with logical 'AND'.
"""
input session_name_choices_comparison_exp {
  _eq: session_name_choices
  _gt: session_name_choices
  _gte: session_name_choices
  _in: [session_name_choices!]
  _is_null: Boolean
  _lt: session_name_choices
  _lte: session_name_choices
  _neq: session_name_choices
  _nin: [session_name_choices!]
}

"""
columns and relationships of "sessions"
"""
type sessions {
  """
  An object relationship
  """
  circuit: circuits
  circuit_id: String
  date: String

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  An object relationship
  """
  event: events
  event_id: String
  id: String!
  name: session_name_choices

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int

  """
  An array relationship
  """
  track_statuses(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  An aggregate relationship
  """
  track_statuses_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!
}

"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

input sessions_aggregate_bool_exp {
  count: sessions_aggregate_bool_exp_count
}

input sessions_aggregate_bool_exp_count {
  arguments: [sessions_select_column!]
  distinct: Boolean
  filter: sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  avg: sessions_avg_fields
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
  stddev: sessions_stddev_fields
  stddev_pop: sessions_stddev_pop_fields
  stddev_samp: sessions_stddev_samp_fields
  sum: sessions_sum_fields
  var_pop: sessions_var_pop_fields
  var_samp: sessions_var_samp_fields
  variance: sessions_variance_fields
}

"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  avg: sessions_avg_order_by
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
  stddev: sessions_stddev_order_by
  stddev_pop: sessions_stddev_pop_order_by
  stddev_samp: sessions_stddev_samp_order_by
  sum: sessions_sum_order_by
  var_pop: sessions_var_pop_order_by
  var_samp: sessions_var_samp_order_by
  variance: sessions_variance_order_by
}

"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!

  """
  upsert condition
  """
  on_conflict: sessions_on_conflict
}

"""
aggregate avg on columns
"""
type sessions_avg_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by avg() on columns of table "sessions"
"""
input sessions_avg_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  circuit: circuits_bool_exp
  circuit_id: String_comparison_exp
  date: String_comparison_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  event: events_bool_exp
  event_id: String_comparison_exp
  id: String_comparison_exp
  name: session_name_choices_comparison_exp
  race_control_messages: race_control_messages_bool_exp
  race_control_messages_aggregate: race_control_messages_aggregate_bool_exp
  scheduled_laps: Int_comparison_exp
  scheduled_start_time: String_comparison_exp
  scheduled_start_time_utc: String_comparison_exp
  start_time: String_comparison_exp
  total_laps: Int_comparison_exp
  track_statuses: track_status_bool_exp
  track_statuses_aggregate: track_status_aggregate_bool_exp
  weather_data: weather_data_bool_exp
  weather_data_aggregate: weather_data_aggregate_bool_exp
}

"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for incrementing numeric columns in table "sessions"
"""
input sessions_inc_input {
  scheduled_laps: Int
  total_laps: Int
}

"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  circuit: circuits_obj_rel_insert_input
  circuit_id: String
  date: String
  driver_sessions: driver_sessions_arr_rel_insert_input
  event: events_obj_rel_insert_input
  event_id: String
  id: String
  name: session_name_choices
  race_control_messages: race_control_messages_arr_rel_insert_input
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
  track_statuses: track_status_arr_rel_insert_input
  weather_data: weather_data_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type sessions_max_fields {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  circuit_id: order_by
  date: order_by
  event_id: order_by
  id: order_by
  name: order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
}

"""
aggregate min on columns
"""
type sessions_min_fields {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  circuit_id: order_by
  date: order_by
  event_id: order_by
  id: order_by
  name: order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
}

"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [sessions!]!
}

"""
input type for inserting object relation for remote table "sessions"
"""
input sessions_obj_rel_insert_input {
  data: sessions_insert_input!

  """
  upsert condition
  """
  on_conflict: sessions_on_conflict
}

"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}

"""
Ordering options when selecting data from "sessions".
"""
input sessions_order_by {
  circuit: circuits_order_by
  circuit_id: order_by
  date: order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  name: order_by
  race_control_messages_aggregate: race_control_messages_aggregate_order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
  track_statuses_aggregate: track_status_aggregate_order_by
  weather_data_aggregate: weather_data_aggregate_order_by
}

"""
primary key columns input for table: sessions
"""
input sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "sessions"
"""
enum sessions_select_column {
  """
  column name
  """
  circuit_id

  """
  column name
  """
  date

  """
  column name
  """
  event_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  scheduled_laps

  """
  column name
  """
  scheduled_start_time

  """
  column name
  """
  scheduled_start_time_utc

  """
  column name
  """
  start_time

  """
  column name
  """
  total_laps
}

"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
aggregate stddev on columns
"""
type sessions_stddev_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev() on columns of table "sessions"
"""
input sessions_stddev_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate stddev_pop on columns
"""
type sessions_stddev_pop_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev_pop() on columns of table "sessions"
"""
input sessions_stddev_pop_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate stddev_samp on columns
"""
type sessions_stddev_samp_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev_samp() on columns of table "sessions"
"""
input sessions_stddev_samp_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: sessions_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input sessions_stream_cursor_value_input {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
aggregate sum on columns
"""
type sessions_sum_fields {
  scheduled_laps: Int
  total_laps: Int
}

"""
order by sum() on columns of table "sessions"
"""
input sessions_sum_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
update columns of table "sessions"
"""
enum sessions_update_column {
  """
  column name
  """
  circuit_id

  """
  column name
  """
  date

  """
  column name
  """
  event_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  scheduled_laps

  """
  column name
  """
  scheduled_start_time

  """
  column name
  """
  scheduled_start_time_utc

  """
  column name
  """
  start_time

  """
  column name
  """
  total_laps
}

input sessions_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: sessions_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: sessions_set_input

  """
  filter the rows which have to be updated
  """
  where: sessions_bool_exp!
}

"""
aggregate var_pop on columns
"""
type sessions_var_pop_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by var_pop() on columns of table "sessions"
"""
input sessions_var_pop_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate var_samp on columns
"""
type sessions_var_samp_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by var_samp() on columns of table "sessions"
"""
input sessions_var_samp_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate variance on columns
"""
type sessions_variance_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by variance() on columns of table "sessions"
"""
input sessions_variance_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

type subscription_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): circuits_aggregate!

  """
  fetch data from the table: "circuits" using primary key columns
  """
  circuits_by_pk(id: String!): circuits

  """
  fetch data from the table in a streaming manner: "circuits"
  """
  circuits_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [circuits_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  fetch data from the table: "constructor_standings" using primary key columns
  """
  constructor_standings_by_pk(id: String!): constructor_standings

  """
  fetch data from the table in a streaming manner: "constructor_standings"
  """
  constructor_standings_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [constructor_standings_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): constructors_aggregate!

  """
  fetch data from the table: "constructors" using primary key columns
  """
  constructors_by_pk(id: String!): constructors

  """
  fetch data from the table in a streaming manner: "constructors"
  """
  constructors_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [constructors_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  fetch data from the table: "driver_sessions" using primary key columns
  """
  driver_sessions_by_pk(id: String!): driver_sessions

  """
  fetch data from the table in a streaming manner: "driver_sessions"
  """
  driver_sessions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [driver_sessions_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!

  """
  fetch data from the table: "driver_standings" using primary key columns
  """
  driver_standings_by_pk(id: String!): driver_standings

  """
  fetch data from the table in a streaming manner: "driver_standings"
  """
  driver_standings_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [driver_standings_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): drivers_aggregate!

  """
  fetch data from the table: "drivers" using primary key columns
  """
  drivers_by_pk(id: String!): drivers

  """
  fetch data from the table in a streaming manner: "drivers"
  """
  drivers_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [drivers_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  fetch data from the table: "events" using primary key columns
  """
  events_by_pk(id: String!): events

  """
  fetch data from the table in a streaming manner: "events"
  """
  events_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [events_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  fetch data from the table: "laps" using primary key columns
  """
  laps_by_pk(id: String!): laps

  """
  fetch data from the table in a streaming manner: "laps"
  """
  laps_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [laps_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!

  """
  fetch data from the table: "race_control_messages" using primary key columns
  """
  race_control_messages_by_pk(id: String!): race_control_messages

  """
  fetch data from the table in a streaming manner: "race_control_messages"
  """
  race_control_messages_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [race_control_messages_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  fetch data from the table: "results" using primary key columns
  """
  results_by_pk(id: String!): results

  """
  fetch data from the table in a streaming manner: "results"
  """
  results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [results_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [sessions_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch data from the table: "telemetry"
  """
  telemetry(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch aggregated fields from the table: "telemetry"
  """
  telemetry_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!

  """
  fetch data from the table: "telemetry" using primary key columns
  """
  telemetry_by_pk(id: String!): telemetry

  """
  fetch data from the table in a streaming manner: "telemetry"
  """
  telemetry_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [telemetry_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch data from the table: "track_status"
  """
  track_status(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  fetch aggregated fields from the table: "track_status"
  """
  track_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  fetch data from the table: "track_status" using primary key columns
  """
  track_status_by_pk(id: String!): track_status

  """
  fetch data from the table in a streaming manner: "track_status"
  """
  track_status_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [track_status_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!

  """
  fetch data from the table: "weather_data" using primary key columns
  """
  weather_data_by_pk(id: String!): weather_data

  """
  fetch data from the table in a streaming manner: "weather_data"
  """
  weather_data_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [weather_data_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!
}

"""
columns and relationships of "telemetry"
"""
type telemetry {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String
  drs: Int
  gear: Int
  id: String!
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregated selection of "telemetry"
"""
type telemetry_aggregate {
  aggregate: telemetry_aggregate_fields
  nodes: [telemetry!]!
}

input telemetry_aggregate_bool_exp {
  bool_and: telemetry_aggregate_bool_exp_bool_and
  bool_or: telemetry_aggregate_bool_exp_bool_or
  count: telemetry_aggregate_bool_exp_count
}

input telemetry_aggregate_bool_exp_bool_and {
  arguments: telemetry_select_column_telemetry_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Boolean_comparison_exp!
}

input telemetry_aggregate_bool_exp_bool_or {
  arguments: telemetry_select_column_telemetry_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Boolean_comparison_exp!
}

input telemetry_aggregate_bool_exp_count {
  arguments: [telemetry_select_column!]
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "telemetry"
"""
type telemetry_aggregate_fields {
  avg: telemetry_avg_fields
  count(columns: [telemetry_select_column!], distinct: Boolean): Int!
  max: telemetry_max_fields
  min: telemetry_min_fields
  stddev: telemetry_stddev_fields
  stddev_pop: telemetry_stddev_pop_fields
  stddev_samp: telemetry_stddev_samp_fields
  sum: telemetry_sum_fields
  var_pop: telemetry_var_pop_fields
  var_samp: telemetry_var_samp_fields
  variance: telemetry_variance_fields
}

"""
order by aggregate values of table "telemetry"
"""
input telemetry_aggregate_order_by {
  avg: telemetry_avg_order_by
  count: order_by
  max: telemetry_max_order_by
  min: telemetry_min_order_by
  stddev: telemetry_stddev_order_by
  stddev_pop: telemetry_stddev_pop_order_by
  stddev_samp: telemetry_stddev_samp_order_by
  sum: telemetry_sum_order_by
  var_pop: telemetry_var_pop_order_by
  var_samp: telemetry_var_samp_order_by
  variance: telemetry_variance_order_by
}

"""
input type for inserting array relation for remote table "telemetry"
"""
input telemetry_arr_rel_insert_input {
  data: [telemetry_insert_input!]!

  """
  upsert condition
  """
  on_conflict: telemetry_on_conflict
}

"""
aggregate avg on columns
"""
type telemetry_avg_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by avg() on columns of table "telemetry"
"""
input telemetry_avg_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
Boolean expression to filter rows from the table "telemetry". All fields are combined with a logical 'AND'.
"""
input telemetry_bool_exp {
  _and: [telemetry_bool_exp!]
  _not: telemetry_bool_exp
  _or: [telemetry_bool_exp!]
  brake: Boolean_comparison_exp
  date: String_comparison_exp
  distance: numeric_comparison_exp
  distance_to_driver_ahead: numeric_comparison_exp
  driver_ahead: String_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  drs: Int_comparison_exp
  gear: Int_comparison_exp
  id: String_comparison_exp
  relative_distance: numeric_comparison_exp
  rpm: Int_comparison_exp
  session_time: bigint_comparison_exp
  source: telemetry_sources_comparison_exp
  speed: numeric_comparison_exp
  status: telemetry_car_status_comparison_exp
  throttle: numeric_comparison_exp
  time: bigint_comparison_exp
  x: numeric_comparison_exp
  y: numeric_comparison_exp
  z: numeric_comparison_exp
}

scalar telemetry_car_status

"""
Boolean expression to compare columns of type "telemetry_car_status". All fields are combined with logical 'AND'.
"""
input telemetry_car_status_comparison_exp {
  _eq: telemetry_car_status
  _gt: telemetry_car_status
  _gte: telemetry_car_status
  _in: [telemetry_car_status!]
  _is_null: Boolean
  _lt: telemetry_car_status
  _lte: telemetry_car_status
  _neq: telemetry_car_status
  _nin: [telemetry_car_status!]
}

"""
unique or primary key constraints on table "telemetry"
"""
enum telemetry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  telemetry_pkey
}

"""
input type for incrementing numeric columns in table "telemetry"
"""
input telemetry_inc_input {
  distance: numeric
  distance_to_driver_ahead: numeric
  drs: Int
  gear: Int
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  speed: numeric
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
input type for inserting data into table "telemetry"
"""
input telemetry_insert_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregate max on columns
"""
type telemetry_max_fields {
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by max() on columns of table "telemetry"
"""
input telemetry_max_order_by {
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate min on columns
"""
type telemetry_min_fields {
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by min() on columns of table "telemetry"
"""
input telemetry_min_order_by {
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
response of any mutation on the table "telemetry"
"""
type telemetry_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [telemetry!]!
}

"""
on_conflict condition type for table "telemetry"
"""
input telemetry_on_conflict {
  constraint: telemetry_constraint!
  update_columns: [telemetry_update_column!]! = []
  where: telemetry_bool_exp
}

"""
Ordering options when selecting data from "telemetry".
"""
input telemetry_order_by {
  brake: order_by
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
primary key columns input for table: telemetry
"""
input telemetry_pk_columns_input {
  id: String!
}

"""
select columns of table "telemetry"
"""
enum telemetry_select_column {
  """
  column name
  """
  brake

  """
  column name
  """
  date

  """
  column name
  """
  distance

  """
  column name
  """
  distance_to_driver_ahead

  """
  column name
  """
  driver_ahead

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  drs

  """
  column name
  """
  gear

  """
  column name
  """
  id

  """
  column name
  """
  relative_distance

  """
  column name
  """
  rpm

  """
  column name
  """
  session_time

  """
  column name
  """
  source

  """
  column name
  """
  speed

  """
  column name
  """
  status

  """
  column name
  """
  throttle

  """
  column name
  """
  time

  """
  column name
  """
  x

  """
  column name
  """
  y

  """
  column name
  """
  z
}

"""
select "telemetry_aggregate_bool_exp_bool_and_arguments_columns" columns of table "telemetry"
"""
enum telemetry_select_column_telemetry_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  brake
}

"""
select "telemetry_aggregate_bool_exp_bool_or_arguments_columns" columns of table "telemetry"
"""
enum telemetry_select_column_telemetry_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  brake
}

"""
input type for updating data in table "telemetry"
"""
input telemetry_set_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

scalar telemetry_sources

"""
Boolean expression to compare columns of type "telemetry_sources". All fields are combined with logical 'AND'.
"""
input telemetry_sources_comparison_exp {
  _eq: telemetry_sources
  _gt: telemetry_sources
  _gte: telemetry_sources
  _in: [telemetry_sources!]
  _is_null: Boolean
  _lt: telemetry_sources
  _lte: telemetry_sources
  _neq: telemetry_sources
  _nin: [telemetry_sources!]
}

"""
aggregate stddev on columns
"""
type telemetry_stddev_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev() on columns of table "telemetry"
"""
input telemetry_stddev_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate stddev_pop on columns
"""
type telemetry_stddev_pop_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev_pop() on columns of table "telemetry"
"""
input telemetry_stddev_pop_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate stddev_samp on columns
"""
type telemetry_stddev_samp_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev_samp() on columns of table "telemetry"
"""
input telemetry_stddev_samp_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
Streaming cursor of the table "telemetry"
"""
input telemetry_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: telemetry_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input telemetry_stream_cursor_value_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregate sum on columns
"""
type telemetry_sum_fields {
  distance: numeric
  distance_to_driver_ahead: numeric
  drs: Int
  gear: Int
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  speed: numeric
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by sum() on columns of table "telemetry"
"""
input telemetry_sum_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
update columns of table "telemetry"
"""
enum telemetry_update_column {
  """
  column name
  """
  brake

  """
  column name
  """
  date

  """
  column name
  """
  distance

  """
  column name
  """
  distance_to_driver_ahead

  """
  column name
  """
  driver_ahead

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  drs

  """
  column name
  """
  gear

  """
  column name
  """
  id

  """
  column name
  """
  relative_distance

  """
  column name
  """
  rpm

  """
  column name
  """
  session_time

  """
  column name
  """
  source

  """
  column name
  """
  speed

  """
  column name
  """
  status

  """
  column name
  """
  throttle

  """
  column name
  """
  time

  """
  column name
  """
  x

  """
  column name
  """
  y

  """
  column name
  """
  z
}

input telemetry_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: telemetry_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: telemetry_set_input

  """
  filter the rows which have to be updated
  """
  where: telemetry_bool_exp!
}

"""
aggregate var_pop on columns
"""
type telemetry_var_pop_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by var_pop() on columns of table "telemetry"
"""
input telemetry_var_pop_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate var_samp on columns
"""
type telemetry_var_samp_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by var_samp() on columns of table "telemetry"
"""
input telemetry_var_samp_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate variance on columns
"""
type telemetry_variance_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by variance() on columns of table "telemetry"
"""
input telemetry_variance_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
columns and relationships of "track_status"
"""
type track_status {
  id: String!
  message: String

  """
  An object relationship
  """
  session: sessions
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregated selection of "track_status"
"""
type track_status_aggregate {
  aggregate: track_status_aggregate_fields
  nodes: [track_status!]!
}

input track_status_aggregate_bool_exp {
  count: track_status_aggregate_bool_exp_count
}

input track_status_aggregate_bool_exp_count {
  arguments: [track_status_select_column!]
  distinct: Boolean
  filter: track_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "track_status"
"""
type track_status_aggregate_fields {
  avg: track_status_avg_fields
  count(columns: [track_status_select_column!], distinct: Boolean): Int!
  max: track_status_max_fields
  min: track_status_min_fields
  stddev: track_status_stddev_fields
  stddev_pop: track_status_stddev_pop_fields
  stddev_samp: track_status_stddev_samp_fields
  sum: track_status_sum_fields
  var_pop: track_status_var_pop_fields
  var_samp: track_status_var_samp_fields
  variance: track_status_variance_fields
}

"""
order by aggregate values of table "track_status"
"""
input track_status_aggregate_order_by {
  avg: track_status_avg_order_by
  count: order_by
  max: track_status_max_order_by
  min: track_status_min_order_by
  stddev: track_status_stddev_order_by
  stddev_pop: track_status_stddev_pop_order_by
  stddev_samp: track_status_stddev_samp_order_by
  sum: track_status_sum_order_by
  var_pop: track_status_var_pop_order_by
  var_samp: track_status_var_samp_order_by
  variance: track_status_variance_order_by
}

"""
input type for inserting array relation for remote table "track_status"
"""
input track_status_arr_rel_insert_input {
  data: [track_status_insert_input!]!

  """
  upsert condition
  """
  on_conflict: track_status_on_conflict
}

"""
aggregate avg on columns
"""
type track_status_avg_fields {
  session_time: Float
}

"""
order by avg() on columns of table "track_status"
"""
input track_status_avg_order_by {
  session_time: order_by
}

"""
Boolean expression to filter rows from the table "track_status". All fields are combined with a logical 'AND'.
"""
input track_status_bool_exp {
  _and: [track_status_bool_exp!]
  _not: track_status_bool_exp
  _or: [track_status_bool_exp!]
  id: String_comparison_exp
  message: String_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  session_time: bigint_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "track_status"
"""
enum track_status_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  track_status_pkey
}

"""
input type for incrementing numeric columns in table "track_status"
"""
input track_status_inc_input {
  session_time: bigint
}

"""
input type for inserting data into table "track_status"
"""
input track_status_insert_input {
  id: String
  message: String
  session: sessions_obj_rel_insert_input
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate max on columns
"""
type track_status_max_fields {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
order by max() on columns of table "track_status"
"""
input track_status_max_order_by {
  id: order_by
  message: order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
aggregate min on columns
"""
type track_status_min_fields {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
order by min() on columns of table "track_status"
"""
input track_status_min_order_by {
  id: order_by
  message: order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
response of any mutation on the table "track_status"
"""
type track_status_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [track_status!]!
}

"""
on_conflict condition type for table "track_status"
"""
input track_status_on_conflict {
  constraint: track_status_constraint!
  update_columns: [track_status_update_column!]! = []
  where: track_status_bool_exp
}

"""
Ordering options when selecting data from "track_status".
"""
input track_status_order_by {
  id: order_by
  message: order_by
  session: sessions_order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
primary key columns input for table: track_status
"""
input track_status_pk_columns_input {
  id: String!
}

"""
select columns of table "track_status"
"""
enum track_status_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  status
}

"""
input type for updating data in table "track_status"
"""
input track_status_set_input {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate stddev on columns
"""
type track_status_stddev_fields {
  session_time: Float
}

"""
order by stddev() on columns of table "track_status"
"""
input track_status_stddev_order_by {
  session_time: order_by
}

"""
aggregate stddev_pop on columns
"""
type track_status_stddev_pop_fields {
  session_time: Float
}

"""
order by stddev_pop() on columns of table "track_status"
"""
input track_status_stddev_pop_order_by {
  session_time: order_by
}

"""
aggregate stddev_samp on columns
"""
type track_status_stddev_samp_fields {
  session_time: Float
}

"""
order by stddev_samp() on columns of table "track_status"
"""
input track_status_stddev_samp_order_by {
  session_time: order_by
}

"""
Streaming cursor of the table "track_status"
"""
input track_status_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: track_status_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input track_status_stream_cursor_value_input {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate sum on columns
"""
type track_status_sum_fields {
  session_time: bigint
}

"""
order by sum() on columns of table "track_status"
"""
input track_status_sum_order_by {
  session_time: order_by
}

"""
update columns of table "track_status"
"""
enum track_status_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  status
}

input track_status_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: track_status_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: track_status_set_input

  """
  filter the rows which have to be updated
  """
  where: track_status_bool_exp!
}

"""
aggregate var_pop on columns
"""
type track_status_var_pop_fields {
  session_time: Float
}

"""
order by var_pop() on columns of table "track_status"
"""
input track_status_var_pop_order_by {
  session_time: order_by
}

"""
aggregate var_samp on columns
"""
type track_status_var_samp_fields {
  session_time: Float
}

"""
order by var_samp() on columns of table "track_status"
"""
input track_status_var_samp_order_by {
  session_time: order_by
}

"""
aggregate variance on columns
"""
type track_status_variance_fields {
  session_time: Float
}

"""
order by variance() on columns of table "track_status"
"""
input track_status_variance_order_by {
  session_time: order_by
}

scalar tyre_compounds

"""
Boolean expression to compare columns of type "tyre_compounds". All fields are combined with logical 'AND'.
"""
input tyre_compounds_comparison_exp {
  _eq: tyre_compounds
  _gt: tyre_compounds
  _gte: tyre_compounds
  _in: [tyre_compounds!]
  _is_null: Boolean
  _lt: tyre_compounds
  _lte: tyre_compounds
  _neq: tyre_compounds
  _nin: [tyre_compounds!]
}

"""
columns and relationships of "weather_data"
"""
type weather_data {
  air_temperature: numeric
  humidity: numeric
  id: String!
  pressure: numeric
  rainfall: Boolean

  """
  An object relationship
  """
  session: sessions
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregated selection of "weather_data"
"""
type weather_data_aggregate {
  aggregate: weather_data_aggregate_fields
  nodes: [weather_data!]!
}

input weather_data_aggregate_bool_exp {
  bool_and: weather_data_aggregate_bool_exp_bool_and
  bool_or: weather_data_aggregate_bool_exp_bool_or
  count: weather_data_aggregate_bool_exp_count
}

input weather_data_aggregate_bool_exp_bool_and {
  arguments: weather_data_select_column_weather_data_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input weather_data_aggregate_bool_exp_bool_or {
  arguments: weather_data_select_column_weather_data_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input weather_data_aggregate_bool_exp_count {
  arguments: [weather_data_select_column!]
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "weather_data"
"""
type weather_data_aggregate_fields {
  avg: weather_data_avg_fields
  count(columns: [weather_data_select_column!], distinct: Boolean): Int!
  max: weather_data_max_fields
  min: weather_data_min_fields
  stddev: weather_data_stddev_fields
  stddev_pop: weather_data_stddev_pop_fields
  stddev_samp: weather_data_stddev_samp_fields
  sum: weather_data_sum_fields
  var_pop: weather_data_var_pop_fields
  var_samp: weather_data_var_samp_fields
  variance: weather_data_variance_fields
}

"""
order by aggregate values of table "weather_data"
"""
input weather_data_aggregate_order_by {
  avg: weather_data_avg_order_by
  count: order_by
  max: weather_data_max_order_by
  min: weather_data_min_order_by
  stddev: weather_data_stddev_order_by
  stddev_pop: weather_data_stddev_pop_order_by
  stddev_samp: weather_data_stddev_samp_order_by
  sum: weather_data_sum_order_by
  var_pop: weather_data_var_pop_order_by
  var_samp: weather_data_var_samp_order_by
  variance: weather_data_variance_order_by
}

"""
input type for inserting array relation for remote table "weather_data"
"""
input weather_data_arr_rel_insert_input {
  data: [weather_data_insert_input!]!

  """
  upsert condition
  """
  on_conflict: weather_data_on_conflict
}

"""
aggregate avg on columns
"""
type weather_data_avg_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by avg() on columns of table "weather_data"
"""
input weather_data_avg_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
Boolean expression to filter rows from the table "weather_data". All fields are combined with a logical 'AND'.
"""
input weather_data_bool_exp {
  _and: [weather_data_bool_exp!]
  _not: weather_data_bool_exp
  _or: [weather_data_bool_exp!]
  air_temperature: numeric_comparison_exp
  humidity: numeric_comparison_exp
  id: String_comparison_exp
  pressure: numeric_comparison_exp
  rainfall: Boolean_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  session_time: bigint_comparison_exp
  track_temperature: numeric_comparison_exp
  wind_direction: Int_comparison_exp
  wind_speed: numeric_comparison_exp
}

"""
unique or primary key constraints on table "weather_data"
"""
enum weather_data_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  weather_data_pkey
}

"""
input type for incrementing numeric columns in table "weather_data"
"""
input weather_data_inc_input {
  air_temperature: numeric
  humidity: numeric
  pressure: numeric
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
input type for inserting data into table "weather_data"
"""
input weather_data_insert_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session: sessions_obj_rel_insert_input
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate max on columns
"""
type weather_data_max_fields {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by max() on columns of table "weather_data"
"""
input weather_data_max_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate min on columns
"""
type weather_data_min_fields {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by min() on columns of table "weather_data"
"""
input weather_data_min_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
response of any mutation on the table "weather_data"
"""
type weather_data_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [weather_data!]!
}

"""
on_conflict condition type for table "weather_data"
"""
input weather_data_on_conflict {
  constraint: weather_data_constraint!
  update_columns: [weather_data_update_column!]! = []
  where: weather_data_bool_exp
}

"""
Ordering options when selecting data from "weather_data".
"""
input weather_data_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  rainfall: order_by
  session: sessions_order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
primary key columns input for table: weather_data
"""
input weather_data_pk_columns_input {
  id: String!
}

"""
select columns of table "weather_data"
"""
enum weather_data_select_column {
  """
  column name
  """
  air_temperature

  """
  column name
  """
  humidity

  """
  column name
  """
  id

  """
  column name
  """
  pressure

  """
  column name
  """
  rainfall

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  track_temperature

  """
  column name
  """
  wind_direction

  """
  column name
  """
  wind_speed
}

"""
select "weather_data_aggregate_bool_exp_bool_and_arguments_columns" columns of table "weather_data"
"""
enum weather_data_select_column_weather_data_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  rainfall
}

"""
select "weather_data_aggregate_bool_exp_bool_or_arguments_columns" columns of table "weather_data"
"""
enum weather_data_select_column_weather_data_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  rainfall
}

"""
input type for updating data in table "weather_data"
"""
input weather_data_set_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate stddev on columns
"""
type weather_data_stddev_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev() on columns of table "weather_data"
"""
input weather_data_stddev_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate stddev_pop on columns
"""
type weather_data_stddev_pop_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev_pop() on columns of table "weather_data"
"""
input weather_data_stddev_pop_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate stddev_samp on columns
"""
type weather_data_stddev_samp_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev_samp() on columns of table "weather_data"
"""
input weather_data_stddev_samp_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
Streaming cursor of the table "weather_data"
"""
input weather_data_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: weather_data_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input weather_data_stream_cursor_value_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate sum on columns
"""
type weather_data_sum_fields {
  air_temperature: numeric
  humidity: numeric
  pressure: numeric
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by sum() on columns of table "weather_data"
"""
input weather_data_sum_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
update columns of table "weather_data"
"""
enum weather_data_update_column {
  """
  column name
  """
  air_temperature

  """
  column name
  """
  humidity

  """
  column name
  """
  id

  """
  column name
  """
  pressure

  """
  column name
  """
  rainfall

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  track_temperature

  """
  column name
  """
  wind_direction

  """
  column name
  """
  wind_speed
}

input weather_data_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: weather_data_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: weather_data_set_input

  """
  filter the rows which have to be updated
  """
  where: weather_data_bool_exp!
}

"""
aggregate var_pop on columns
"""
type weather_data_var_pop_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by var_pop() on columns of table "weather_data"
"""
input weather_data_var_pop_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate var_samp on columns
"""
type weather_data_var_samp_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by var_samp() on columns of table "weather_data"
"""
input weather_data_var_samp_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate variance on columns
"""
type weather_data_variance_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by variance() on columns of table "weather_data"
"""
input weather_data_variance_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}
