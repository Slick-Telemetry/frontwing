schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "circuits"
"""
type circuits {
  country: String
  f1_key: Int
  id: String!
  location: String
  name: String

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!
}

"""
aggregated selection of "circuits"
"""
type circuits_aggregate {
  aggregate: circuits_aggregate_fields
  nodes: [circuits!]!
}

"""
aggregate fields of "circuits"
"""
type circuits_aggregate_fields {
  avg: circuits_avg_fields
  count(columns: [circuits_select_column!], distinct: Boolean): Int!
  max: circuits_max_fields
  min: circuits_min_fields
  stddev: circuits_stddev_fields
  stddev_pop: circuits_stddev_pop_fields
  stddev_samp: circuits_stddev_samp_fields
  sum: circuits_sum_fields
  var_pop: circuits_var_pop_fields
  var_samp: circuits_var_samp_fields
  variance: circuits_variance_fields
}

"""
aggregate avg on columns
"""
type circuits_avg_fields {
  f1_key: Float
}

"""
Boolean expression to filter rows from the table "circuits". All fields are combined with a logical 'AND'.
"""
input circuits_bool_exp {
  _and: [circuits_bool_exp!]
  _not: circuits_bool_exp
  _or: [circuits_bool_exp!]
  country: String_comparison_exp
  f1_key: Int_comparison_exp
  id: String_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
}

"""
unique or primary key constraints on table "circuits"
"""
enum circuits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  circuits_pkey
}

"""
input type for incrementing numeric columns in table "circuits"
"""
input circuits_inc_input {
  f1_key: Int
}

"""
input type for inserting data into table "circuits"
"""
input circuits_insert_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
  sessions: sessions_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type circuits_max_fields {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate min on columns
"""
type circuits_min_fields {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
response of any mutation on the table "circuits"
"""
type circuits_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [circuits!]!
}

"""
input type for inserting object relation for remote table "circuits"
"""
input circuits_obj_rel_insert_input {
  data: circuits_insert_input!

  """
  upsert condition
  """
  on_conflict: circuits_on_conflict
}

"""
on_conflict condition type for table "circuits"
"""
input circuits_on_conflict {
  constraint: circuits_constraint!
  update_columns: [circuits_update_column!]! = []
  where: circuits_bool_exp
}

"""
Ordering options when selecting data from "circuits".
"""
input circuits_order_by {
  country: order_by
  f1_key: order_by
  id: order_by
  location: order_by
  name: order_by
  sessions_aggregate: sessions_aggregate_order_by
}

"""
primary key columns input for table: circuits
"""
input circuits_pk_columns_input {
  id: String!
}

"""
select columns of table "circuits"
"""
enum circuits_select_column {
  """
  column name
  """
  country

  """
  column name
  """
  f1_key

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name
}

"""
input type for updating data in table "circuits"
"""
input circuits_set_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate stddev on columns
"""
type circuits_stddev_fields {
  f1_key: Float
}

"""
aggregate stddev_pop on columns
"""
type circuits_stddev_pop_fields {
  f1_key: Float
}

"""
aggregate stddev_samp on columns
"""
type circuits_stddev_samp_fields {
  f1_key: Float
}

"""
Streaming cursor of the table "circuits"
"""
input circuits_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: circuits_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input circuits_stream_cursor_value_input {
  country: String
  f1_key: Int
  id: String
  location: String
  name: String
}

"""
aggregate sum on columns
"""
type circuits_sum_fields {
  f1_key: Int
}

"""
update columns of table "circuits"
"""
enum circuits_update_column {
  """
  column name
  """
  country

  """
  column name
  """
  f1_key

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name
}

input circuits_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: circuits_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: circuits_set_input

  """
  filter the rows which have to be updated
  """
  where: circuits_bool_exp!
}

"""
aggregate var_pop on columns
"""
type circuits_var_pop_fields {
  f1_key: Float
}

"""
aggregate var_samp on columns
"""
type circuits_var_samp_fields {
  f1_key: Float
}

"""
aggregate variance on columns
"""
type circuits_variance_fields {
  f1_key: Float
}

"""
columns and relationships of "constructor_standings"
"""
type constructor_standings {
  """
  An object relationship
  """
  constructorByConstructorId: constructors
  constructor_id: String
  id: String!
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregated selection of "constructor_standings"
"""
type constructor_standings_aggregate {
  aggregate: constructor_standings_aggregate_fields
  nodes: [constructor_standings!]!
}

input constructor_standings_aggregate_bool_exp {
  count: constructor_standings_aggregate_bool_exp_count
}

input constructor_standings_aggregate_bool_exp_count {
  arguments: [constructor_standings_select_column!]
  distinct: Boolean
  filter: constructor_standings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "constructor_standings"
"""
type constructor_standings_aggregate_fields {
  avg: constructor_standings_avg_fields
  count(
    columns: [constructor_standings_select_column!]
    distinct: Boolean
  ): Int!
  max: constructor_standings_max_fields
  min: constructor_standings_min_fields
  stddev: constructor_standings_stddev_fields
  stddev_pop: constructor_standings_stddev_pop_fields
  stddev_samp: constructor_standings_stddev_samp_fields
  sum: constructor_standings_sum_fields
  var_pop: constructor_standings_var_pop_fields
  var_samp: constructor_standings_var_samp_fields
  variance: constructor_standings_variance_fields
}

"""
order by aggregate values of table "constructor_standings"
"""
input constructor_standings_aggregate_order_by {
  avg: constructor_standings_avg_order_by
  count: order_by
  max: constructor_standings_max_order_by
  min: constructor_standings_min_order_by
  stddev: constructor_standings_stddev_order_by
  stddev_pop: constructor_standings_stddev_pop_order_by
  stddev_samp: constructor_standings_stddev_samp_order_by
  sum: constructor_standings_sum_order_by
  var_pop: constructor_standings_var_pop_order_by
  var_samp: constructor_standings_var_samp_order_by
  variance: constructor_standings_variance_order_by
}

"""
input type for inserting array relation for remote table "constructor_standings"
"""
input constructor_standings_arr_rel_insert_input {
  data: [constructor_standings_insert_input!]!

  """
  upsert condition
  """
  on_conflict: constructor_standings_on_conflict
}

"""
aggregate avg on columns
"""
type constructor_standings_avg_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by avg() on columns of table "constructor_standings"
"""
input constructor_standings_avg_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "constructor_standings". All fields are combined with a logical 'AND'.
"""
input constructor_standings_bool_exp {
  _and: [constructor_standings_bool_exp!]
  _not: constructor_standings_bool_exp
  _or: [constructor_standings_bool_exp!]
  constructorByConstructorId: constructors_bool_exp
  constructor_id: String_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  position: Int_comparison_exp
  position_text: String_comparison_exp
  season: Int_comparison_exp
  wins: Int_comparison_exp
}

"""
unique or primary key constraints on table "constructor_standings"
"""
enum constructor_standings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  constructor_standings_pkey
}

"""
input type for incrementing numeric columns in table "constructor_standings"
"""
input constructor_standings_inc_input {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
input type for inserting data into table "constructor_standings"
"""
input constructor_standings_insert_input {
  constructorByConstructorId: constructors_obj_rel_insert_input
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate max on columns
"""
type constructor_standings_max_fields {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by max() on columns of table "constructor_standings"
"""
input constructor_standings_max_order_by {
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
aggregate min on columns
"""
type constructor_standings_min_fields {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by min() on columns of table "constructor_standings"
"""
input constructor_standings_min_order_by {
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
response of any mutation on the table "constructor_standings"
"""
type constructor_standings_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [constructor_standings!]!
}

"""
on_conflict condition type for table "constructor_standings"
"""
input constructor_standings_on_conflict {
  constraint: constructor_standings_constraint!
  update_columns: [constructor_standings_update_column!]! = []
  where: constructor_standings_bool_exp
}

"""
Ordering options when selecting data from "constructor_standings".
"""
input constructor_standings_order_by {
  constructorByConstructorId: constructors_order_by
  constructor_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
primary key columns input for table: constructor_standings
"""
input constructor_standings_pk_columns_input {
  id: String!
}

"""
select columns of table "constructor_standings"
"""
enum constructor_standings_select_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

"""
input type for updating data in table "constructor_standings"
"""
input constructor_standings_set_input {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate stddev on columns
"""
type constructor_standings_stddev_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_pop on columns
"""
type constructor_standings_stddev_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_samp on columns
"""
type constructor_standings_stddev_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "constructor_standings"
"""
input constructor_standings_stddev_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Streaming cursor of the table "constructor_standings"
"""
input constructor_standings_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: constructor_standings_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input constructor_standings_stream_cursor_value_input {
  constructor_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate sum on columns
"""
type constructor_standings_sum_fields {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
order by sum() on columns of table "constructor_standings"
"""
input constructor_standings_sum_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
update columns of table "constructor_standings"
"""
enum constructor_standings_update_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

input constructor_standings_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: constructor_standings_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: constructor_standings_set_input

  """
  filter the rows which have to be updated
  """
  where: constructor_standings_bool_exp!
}

"""
aggregate var_pop on columns
"""
type constructor_standings_var_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_pop() on columns of table "constructor_standings"
"""
input constructor_standings_var_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate var_samp on columns
"""
type constructor_standings_var_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_samp() on columns of table "constructor_standings"
"""
input constructor_standings_var_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate variance on columns
"""
type constructor_standings_variance_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by variance() on columns of table "constructor_standings"
"""
input constructor_standings_variance_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
columns and relationships of "constructors"
"""
type constructors {
  color: String

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!
  engine: String
  ergast_id: String
  id: String!
  name: String
  nationality: String
  start_year: Int
}

"""
aggregated selection of "constructors"
"""
type constructors_aggregate {
  aggregate: constructors_aggregate_fields
  nodes: [constructors!]!
}

"""
aggregate fields of "constructors"
"""
type constructors_aggregate_fields {
  avg: constructors_avg_fields
  count(columns: [constructors_select_column!], distinct: Boolean): Int!
  max: constructors_max_fields
  min: constructors_min_fields
  stddev: constructors_stddev_fields
  stddev_pop: constructors_stddev_pop_fields
  stddev_samp: constructors_stddev_samp_fields
  sum: constructors_sum_fields
  var_pop: constructors_var_pop_fields
  var_samp: constructors_var_samp_fields
  variance: constructors_variance_fields
}

"""
aggregate avg on columns
"""
type constructors_avg_fields {
  start_year: Float
}

"""
Boolean expression to filter rows from the table "constructors". All fields are combined with a logical 'AND'.
"""
input constructors_bool_exp {
  _and: [constructors_bool_exp!]
  _not: constructors_bool_exp
  _or: [constructors_bool_exp!]
  color: String_comparison_exp
  constructor_standings: constructor_standings_bool_exp
  constructor_standings_aggregate: constructor_standings_aggregate_bool_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  engine: String_comparison_exp
  ergast_id: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  nationality: String_comparison_exp
  start_year: Int_comparison_exp
}

"""
unique or primary key constraints on table "constructors"
"""
enum constructors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  constructors_pkey
}

"""
input type for incrementing numeric columns in table "constructors"
"""
input constructors_inc_input {
  start_year: Int
}

"""
input type for inserting data into table "constructors"
"""
input constructors_insert_input {
  color: String
  constructor_standings: constructor_standings_arr_rel_insert_input
  driver_sessions: driver_sessions_arr_rel_insert_input
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate max on columns
"""
type constructors_max_fields {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate min on columns
"""
type constructors_min_fields {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
response of any mutation on the table "constructors"
"""
type constructors_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [constructors!]!
}

"""
input type for inserting object relation for remote table "constructors"
"""
input constructors_obj_rel_insert_input {
  data: constructors_insert_input!

  """
  upsert condition
  """
  on_conflict: constructors_on_conflict
}

"""
on_conflict condition type for table "constructors"
"""
input constructors_on_conflict {
  constraint: constructors_constraint!
  update_columns: [constructors_update_column!]! = []
  where: constructors_bool_exp
}

"""
Ordering options when selecting data from "constructors".
"""
input constructors_order_by {
  color: order_by
  constructor_standings_aggregate: constructor_standings_aggregate_order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  engine: order_by
  ergast_id: order_by
  id: order_by
  name: order_by
  nationality: order_by
  start_year: order_by
}

"""
primary key columns input for table: constructors
"""
input constructors_pk_columns_input {
  id: String!
}

"""
select columns of table "constructors"
"""
enum constructors_select_column {
  """
  column name
  """
  color

  """
  column name
  """
  engine

  """
  column name
  """
  ergast_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  nationality

  """
  column name
  """
  start_year
}

"""
input type for updating data in table "constructors"
"""
input constructors_set_input {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate stddev on columns
"""
type constructors_stddev_fields {
  start_year: Float
}

"""
aggregate stddev_pop on columns
"""
type constructors_stddev_pop_fields {
  start_year: Float
}

"""
aggregate stddev_samp on columns
"""
type constructors_stddev_samp_fields {
  start_year: Float
}

"""
Streaming cursor of the table "constructors"
"""
input constructors_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: constructors_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input constructors_stream_cursor_value_input {
  color: String
  engine: String
  ergast_id: String
  id: String
  name: String
  nationality: String
  start_year: Int
}

"""
aggregate sum on columns
"""
type constructors_sum_fields {
  start_year: Int
}

"""
update columns of table "constructors"
"""
enum constructors_update_column {
  """
  column name
  """
  color

  """
  column name
  """
  engine

  """
  column name
  """
  ergast_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  nationality

  """
  column name
  """
  start_year
}

input constructors_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: constructors_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: constructors_set_input

  """
  filter the rows which have to be updated
  """
  where: constructors_bool_exp!
}

"""
aggregate var_pop on columns
"""
type constructors_var_pop_fields {
  start_year: Float
}

"""
aggregate var_samp on columns
"""
type constructors_var_samp_fields {
  start_year: Float
}

"""
aggregate variance on columns
"""
type constructors_variance_fields {
  start_year: Float
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
columns and relationships of "driver_sessions"
"""
type driver_sessions {
  """
  An object relationship
  """
  constructorByConstructorId: constructors
  constructor_id: String

  """
  An object relationship
  """
  driver: drivers
  driver_id: String
  id: String!

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  An object relationship
  """
  session: sessions
  session_id: String

  """
  An array relationship
  """
  telemetries(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  An aggregate relationship
  """
  telemetries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!
}

"""
aggregated selection of "driver_sessions"
"""
type driver_sessions_aggregate {
  aggregate: driver_sessions_aggregate_fields
  nodes: [driver_sessions!]!
}

input driver_sessions_aggregate_bool_exp {
  count: driver_sessions_aggregate_bool_exp_count
}

input driver_sessions_aggregate_bool_exp_count {
  arguments: [driver_sessions_select_column!]
  distinct: Boolean
  filter: driver_sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "driver_sessions"
"""
type driver_sessions_aggregate_fields {
  count(columns: [driver_sessions_select_column!], distinct: Boolean): Int!
  max: driver_sessions_max_fields
  min: driver_sessions_min_fields
}

"""
order by aggregate values of table "driver_sessions"
"""
input driver_sessions_aggregate_order_by {
  count: order_by
  max: driver_sessions_max_order_by
  min: driver_sessions_min_order_by
}

"""
input type for inserting array relation for remote table "driver_sessions"
"""
input driver_sessions_arr_rel_insert_input {
  data: [driver_sessions_insert_input!]!

  """
  upsert condition
  """
  on_conflict: driver_sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "driver_sessions". All fields are combined with a logical 'AND'.
"""
input driver_sessions_bool_exp {
  _and: [driver_sessions_bool_exp!]
  _not: driver_sessions_bool_exp
  _or: [driver_sessions_bool_exp!]
  constructorByConstructorId: constructors_bool_exp
  constructor_id: String_comparison_exp
  driver: drivers_bool_exp
  driver_id: String_comparison_exp
  id: String_comparison_exp
  laps: laps_bool_exp
  laps_aggregate: laps_aggregate_bool_exp
  results: results_bool_exp
  results_aggregate: results_aggregate_bool_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  telemetries: telemetry_bool_exp
  telemetries_aggregate: telemetry_aggregate_bool_exp
}

"""
unique or primary key constraints on table "driver_sessions"
"""
enum driver_sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  driver_sessions_pkey
}

"""
input type for inserting data into table "driver_sessions"
"""
input driver_sessions_insert_input {
  constructorByConstructorId: constructors_obj_rel_insert_input
  constructor_id: String
  driver: drivers_obj_rel_insert_input
  driver_id: String
  id: String
  laps: laps_arr_rel_insert_input
  results: results_arr_rel_insert_input
  session: sessions_obj_rel_insert_input
  session_id: String
  telemetries: telemetry_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type driver_sessions_max_fields {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
order by max() on columns of table "driver_sessions"
"""
input driver_sessions_max_order_by {
  constructor_id: order_by
  driver_id: order_by
  id: order_by
  session_id: order_by
}

"""
aggregate min on columns
"""
type driver_sessions_min_fields {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
order by min() on columns of table "driver_sessions"
"""
input driver_sessions_min_order_by {
  constructor_id: order_by
  driver_id: order_by
  id: order_by
  session_id: order_by
}

"""
response of any mutation on the table "driver_sessions"
"""
type driver_sessions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [driver_sessions!]!
}

"""
input type for inserting object relation for remote table "driver_sessions"
"""
input driver_sessions_obj_rel_insert_input {
  data: driver_sessions_insert_input!

  """
  upsert condition
  """
  on_conflict: driver_sessions_on_conflict
}

"""
on_conflict condition type for table "driver_sessions"
"""
input driver_sessions_on_conflict {
  constraint: driver_sessions_constraint!
  update_columns: [driver_sessions_update_column!]! = []
  where: driver_sessions_bool_exp
}

"""
Ordering options when selecting data from "driver_sessions".
"""
input driver_sessions_order_by {
  constructorByConstructorId: constructors_order_by
  constructor_id: order_by
  driver: drivers_order_by
  driver_id: order_by
  id: order_by
  laps_aggregate: laps_aggregate_order_by
  results_aggregate: results_aggregate_order_by
  session: sessions_order_by
  session_id: order_by
  telemetries_aggregate: telemetry_aggregate_order_by
}

"""
primary key columns input for table: driver_sessions
"""
input driver_sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "driver_sessions"
"""
enum driver_sessions_select_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  session_id
}

"""
input type for updating data in table "driver_sessions"
"""
input driver_sessions_set_input {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
Streaming cursor of the table "driver_sessions"
"""
input driver_sessions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: driver_sessions_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input driver_sessions_stream_cursor_value_input {
  constructor_id: String
  driver_id: String
  id: String
  session_id: String
}

"""
update columns of table "driver_sessions"
"""
enum driver_sessions_update_column {
  """
  column name
  """
  constructor_id

  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  session_id
}

input driver_sessions_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: driver_sessions_set_input

  """
  filter the rows which have to be updated
  """
  where: driver_sessions_bool_exp!
}

"""
columns and relationships of "driver_standings"
"""
type driver_standings {
  """
  An object relationship
  """
  driver: drivers
  driver_id: String
  id: String!
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregated selection of "driver_standings"
"""
type driver_standings_aggregate {
  aggregate: driver_standings_aggregate_fields
  nodes: [driver_standings!]!
}

input driver_standings_aggregate_bool_exp {
  count: driver_standings_aggregate_bool_exp_count
}

input driver_standings_aggregate_bool_exp_count {
  arguments: [driver_standings_select_column!]
  distinct: Boolean
  filter: driver_standings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "driver_standings"
"""
type driver_standings_aggregate_fields {
  avg: driver_standings_avg_fields
  count(columns: [driver_standings_select_column!], distinct: Boolean): Int!
  max: driver_standings_max_fields
  min: driver_standings_min_fields
  stddev: driver_standings_stddev_fields
  stddev_pop: driver_standings_stddev_pop_fields
  stddev_samp: driver_standings_stddev_samp_fields
  sum: driver_standings_sum_fields
  var_pop: driver_standings_var_pop_fields
  var_samp: driver_standings_var_samp_fields
  variance: driver_standings_variance_fields
}

"""
order by aggregate values of table "driver_standings"
"""
input driver_standings_aggregate_order_by {
  avg: driver_standings_avg_order_by
  count: order_by
  max: driver_standings_max_order_by
  min: driver_standings_min_order_by
  stddev: driver_standings_stddev_order_by
  stddev_pop: driver_standings_stddev_pop_order_by
  stddev_samp: driver_standings_stddev_samp_order_by
  sum: driver_standings_sum_order_by
  var_pop: driver_standings_var_pop_order_by
  var_samp: driver_standings_var_samp_order_by
  variance: driver_standings_variance_order_by
}

"""
input type for inserting array relation for remote table "driver_standings"
"""
input driver_standings_arr_rel_insert_input {
  data: [driver_standings_insert_input!]!

  """
  upsert condition
  """
  on_conflict: driver_standings_on_conflict
}

"""
aggregate avg on columns
"""
type driver_standings_avg_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by avg() on columns of table "driver_standings"
"""
input driver_standings_avg_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "driver_standings". All fields are combined with a logical 'AND'.
"""
input driver_standings_bool_exp {
  _and: [driver_standings_bool_exp!]
  _not: driver_standings_bool_exp
  _or: [driver_standings_bool_exp!]
  driver: drivers_bool_exp
  driver_id: String_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  position: Int_comparison_exp
  position_text: String_comparison_exp
  season: Int_comparison_exp
  wins: Int_comparison_exp
}

"""
unique or primary key constraints on table "driver_standings"
"""
enum driver_standings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  driver_standings_pkey
}

"""
input type for incrementing numeric columns in table "driver_standings"
"""
input driver_standings_inc_input {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
input type for inserting data into table "driver_standings"
"""
input driver_standings_insert_input {
  driver: drivers_obj_rel_insert_input
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate max on columns
"""
type driver_standings_max_fields {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by max() on columns of table "driver_standings"
"""
input driver_standings_max_order_by {
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
aggregate min on columns
"""
type driver_standings_min_fields {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
order by min() on columns of table "driver_standings"
"""
input driver_standings_min_order_by {
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
response of any mutation on the table "driver_standings"
"""
type driver_standings_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [driver_standings!]!
}

"""
on_conflict condition type for table "driver_standings"
"""
input driver_standings_on_conflict {
  constraint: driver_standings_constraint!
  update_columns: [driver_standings_update_column!]! = []
  where: driver_standings_bool_exp
}

"""
Ordering options when selecting data from "driver_standings".
"""
input driver_standings_order_by {
  driver: drivers_order_by
  driver_id: order_by
  id: order_by
  points: order_by
  position: order_by
  position_text: order_by
  season: order_by
  wins: order_by
}

"""
primary key columns input for table: driver_standings
"""
input driver_standings_pk_columns_input {
  id: String!
}

"""
select columns of table "driver_standings"
"""
enum driver_standings_select_column {
  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

"""
input type for updating data in table "driver_standings"
"""
input driver_standings_set_input {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate stddev on columns
"""
type driver_standings_stddev_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev() on columns of table "driver_standings"
"""
input driver_standings_stddev_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_pop on columns
"""
type driver_standings_stddev_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "driver_standings"
"""
input driver_standings_stddev_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate stddev_samp on columns
"""
type driver_standings_stddev_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "driver_standings"
"""
input driver_standings_stddev_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
Streaming cursor of the table "driver_standings"
"""
input driver_standings_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: driver_standings_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input driver_standings_stream_cursor_value_input {
  driver_id: String
  id: String
  points: numeric
  position: Int
  position_text: String
  season: Int
  wins: Int
}

"""
aggregate sum on columns
"""
type driver_standings_sum_fields {
  points: numeric
  position: Int
  season: Int
  wins: Int
}

"""
order by sum() on columns of table "driver_standings"
"""
input driver_standings_sum_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
update columns of table "driver_standings"
"""
enum driver_standings_update_column {
  """
  column name
  """
  driver_id

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  position

  """
  column name
  """
  position_text

  """
  column name
  """
  season

  """
  column name
  """
  wins
}

input driver_standings_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: driver_standings_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: driver_standings_set_input

  """
  filter the rows which have to be updated
  """
  where: driver_standings_bool_exp!
}

"""
aggregate var_pop on columns
"""
type driver_standings_var_pop_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_pop() on columns of table "driver_standings"
"""
input driver_standings_var_pop_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate var_samp on columns
"""
type driver_standings_var_samp_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by var_samp() on columns of table "driver_standings"
"""
input driver_standings_var_samp_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
aggregate variance on columns
"""
type driver_standings_variance_fields {
  points: Float
  position: Float
  season: Float
  wins: Float
}

"""
order by variance() on columns of table "driver_standings"
"""
input driver_standings_variance_order_by {
  points: order_by
  position: order_by
  season: order_by
  wins: order_by
}

"""
columns and relationships of "drivers"
"""
type drivers {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String!
  last_name: String
  nationality: String
  number: String
}

"""
aggregated selection of "drivers"
"""
type drivers_aggregate {
  aggregate: drivers_aggregate_fields
  nodes: [drivers!]!
}

"""
aggregate fields of "drivers"
"""
type drivers_aggregate_fields {
  count(columns: [drivers_select_column!], distinct: Boolean): Int!
  max: drivers_max_fields
  min: drivers_min_fields
}

"""
Boolean expression to filter rows from the table "drivers". All fields are combined with a logical 'AND'.
"""
input drivers_bool_exp {
  _and: [drivers_bool_exp!]
  _not: drivers_bool_exp
  _or: [drivers_bool_exp!]
  abbreviation: String_comparison_exp
  broadcast_name: String_comparison_exp
  country_code: String_comparison_exp
  date_of_birth: String_comparison_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  driver_standings: driver_standings_bool_exp
  driver_standings_aggregate: driver_standings_aggregate_bool_exp
  ergast_id: String_comparison_exp
  first_name: String_comparison_exp
  full_name: String_comparison_exp
  headshot_url: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
  nationality: String_comparison_exp
  number: String_comparison_exp
}

"""
unique or primary key constraints on table "drivers"
"""
enum drivers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  drivers_pkey
}

"""
input type for inserting data into table "drivers"
"""
input drivers_insert_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  driver_sessions: driver_sessions_arr_rel_insert_input
  driver_standings: driver_standings_arr_rel_insert_input
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
aggregate max on columns
"""
type drivers_max_fields {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
aggregate min on columns
"""
type drivers_min_fields {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
response of any mutation on the table "drivers"
"""
type drivers_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [drivers!]!
}

"""
input type for inserting object relation for remote table "drivers"
"""
input drivers_obj_rel_insert_input {
  data: drivers_insert_input!

  """
  upsert condition
  """
  on_conflict: drivers_on_conflict
}

"""
on_conflict condition type for table "drivers"
"""
input drivers_on_conflict {
  constraint: drivers_constraint!
  update_columns: [drivers_update_column!]! = []
  where: drivers_bool_exp
}

"""
Ordering options when selecting data from "drivers".
"""
input drivers_order_by {
  abbreviation: order_by
  broadcast_name: order_by
  country_code: order_by
  date_of_birth: order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  driver_standings_aggregate: driver_standings_aggregate_order_by
  ergast_id: order_by
  first_name: order_by
  full_name: order_by
  headshot_url: order_by
  id: order_by
  last_name: order_by
  nationality: order_by
  number: order_by
}

"""
primary key columns input for table: drivers
"""
input drivers_pk_columns_input {
  id: String!
}

"""
select columns of table "drivers"
"""
enum drivers_select_column {
  """
  column name
  """
  abbreviation

  """
  column name
  """
  broadcast_name

  """
  column name
  """
  country_code

  """
  column name
  """
  date_of_birth

  """
  column name
  """
  ergast_id

  """
  column name
  """
  first_name

  """
  column name
  """
  full_name

  """
  column name
  """
  headshot_url

  """
  column name
  """
  id

  """
  column name
  """
  last_name

  """
  column name
  """
  nationality

  """
  column name
  """
  number
}

"""
input type for updating data in table "drivers"
"""
input drivers_set_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
Streaming cursor of the table "drivers"
"""
input drivers_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: drivers_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input drivers_stream_cursor_value_input {
  abbreviation: String
  broadcast_name: String
  country_code: String
  date_of_birth: String
  ergast_id: String
  first_name: String
  full_name: String
  headshot_url: String
  id: String
  last_name: String
  nationality: String
  number: String
}

"""
update columns of table "drivers"
"""
enum drivers_update_column {
  """
  column name
  """
  abbreviation

  """
  column name
  """
  broadcast_name

  """
  column name
  """
  country_code

  """
  column name
  """
  date_of_birth

  """
  column name
  """
  ergast_id

  """
  column name
  """
  first_name

  """
  column name
  """
  full_name

  """
  column name
  """
  headshot_url

  """
  column name
  """
  id

  """
  column name
  """
  last_name

  """
  column name
  """
  nationality

  """
  column name
  """
  number
}

input drivers_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: drivers_set_input

  """
  filter the rows which have to be updated
  """
  where: drivers_bool_exp!
}

scalar event_format_choices

"""
Boolean expression to compare columns of type "event_format_choices". All fields are combined with logical 'AND'.
"""
input event_format_choices_comparison_exp {
  _eq: event_format_choices
  _gt: event_format_choices
  _gte: event_format_choices
  _in: [event_format_choices!]
  _is_null: Boolean
  _lt: event_format_choices
  _lte: event_format_choices
  _neq: event_format_choices
  _nin: [event_format_choices!]
}

"""
columns and relationships of "events"
"""
type events {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String!
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!
  year: Int
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  avg: events_avg_fields
  count(columns: [events_select_column!], distinct: Boolean): Int!
  max: events_max_fields
  min: events_min_fields
  stddev: events_stddev_fields
  stddev_pop: events_stddev_pop_fields
  stddev_samp: events_stddev_samp_fields
  sum: events_sum_fields
  var_pop: events_var_pop_fields
  var_samp: events_var_samp_fields
  variance: events_variance_fields
}

"""
aggregate avg on columns
"""
type events_avg_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  country: String_comparison_exp
  date: String_comparison_exp
  f1_api_support: Boolean_comparison_exp
  format: event_format_choices_comparison_exp
  id: String_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  official_name: String_comparison_exp
  round_number: Int_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
  year: Int_comparison_exp
}

"""
unique or primary key constraints on table "events"
"""
enum events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  events_pkey
}

"""
input type for incrementing numeric columns in table "events"
"""
input events_inc_input {
  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  sessions: sessions_arr_rel_insert_input
  year: Int
}

"""
aggregate max on columns
"""
type events_max_fields {
  country: String
  date: String
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate min on columns
"""
type events_min_fields {
  country: String
  date: String
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [events!]!
}

"""
input type for inserting object relation for remote table "events"
"""
input events_obj_rel_insert_input {
  data: events_insert_input!

  """
  upsert condition
  """
  on_conflict: events_on_conflict
}

"""
on_conflict condition type for table "events"
"""
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]! = []
  where: events_bool_exp
}

"""
Ordering options when selecting data from "events".
"""
input events_order_by {
  country: order_by
  date: order_by
  f1_api_support: order_by
  format: order_by
  id: order_by
  location: order_by
  name: order_by
  official_name: order_by
  round_number: order_by
  sessions_aggregate: sessions_aggregate_order_by
  year: order_by
}

"""
primary key columns input for table: events
"""
input events_pk_columns_input {
  id: String!
}

"""
select columns of table "events"
"""
enum events_select_column {
  """
  column name
  """
  country

  """
  column name
  """
  date

  """
  column name
  """
  f1_api_support

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name

  """
  column name
  """
  official_name

  """
  column name
  """
  round_number

  """
  column name
  """
  year
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate stddev on columns
"""
type events_stddev_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate stddev_pop on columns
"""
type events_stddev_pop_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate stddev_samp on columns
"""
type events_stddev_samp_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
Streaming cursor of the table "events"
"""
input events_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: events_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input events_stream_cursor_value_input {
  country: String
  date: String
  f1_api_support: Boolean
  format: event_format_choices
  id: String
  location: String
  name: String
  official_name: String

  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
aggregate sum on columns
"""
type events_sum_fields {
  """
  All test sessions = 0
  """
  round_number: Int
  year: Int
}

"""
update columns of table "events"
"""
enum events_update_column {
  """
  column name
  """
  country

  """
  column name
  """
  date

  """
  column name
  """
  f1_api_support

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  name

  """
  column name
  """
  official_name

  """
  column name
  """
  round_number

  """
  column name
  """
  year
}

input events_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: events_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: events_set_input

  """
  filter the rows which have to be updated
  """
  where: events_bool_exp!
}

"""
aggregate var_pop on columns
"""
type events_var_pop_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate var_samp on columns
"""
type events_var_samp_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
aggregate variance on columns
"""
type events_variance_fields {
  """
  All test sessions = 0
  """
  round_number: Float
  year: Float
}

"""
columns and relationships of "laps"
"""
type laps {
  compound: tyre_compounds

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String
  fresh_tyre: Boolean
  id: String!
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregated selection of "laps"
"""
type laps_aggregate {
  aggregate: laps_aggregate_fields
  nodes: [laps!]!
}

input laps_aggregate_bool_exp {
  bool_and: laps_aggregate_bool_exp_bool_and
  bool_or: laps_aggregate_bool_exp_bool_or
  count: laps_aggregate_bool_exp_count
}

input laps_aggregate_bool_exp_bool_and {
  arguments: laps_select_column_laps_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Boolean_comparison_exp!
}

input laps_aggregate_bool_exp_bool_or {
  arguments: laps_select_column_laps_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Boolean_comparison_exp!
}

input laps_aggregate_bool_exp_count {
  arguments: [laps_select_column!]
  distinct: Boolean
  filter: laps_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "laps"
"""
type laps_aggregate_fields {
  avg: laps_avg_fields
  count(columns: [laps_select_column!], distinct: Boolean): Int!
  max: laps_max_fields
  min: laps_min_fields
  stddev: laps_stddev_fields
  stddev_pop: laps_stddev_pop_fields
  stddev_samp: laps_stddev_samp_fields
  sum: laps_sum_fields
  var_pop: laps_var_pop_fields
  var_samp: laps_var_samp_fields
  variance: laps_variance_fields
}

"""
order by aggregate values of table "laps"
"""
input laps_aggregate_order_by {
  avg: laps_avg_order_by
  count: order_by
  max: laps_max_order_by
  min: laps_min_order_by
  stddev: laps_stddev_order_by
  stddev_pop: laps_stddev_pop_order_by
  stddev_samp: laps_stddev_samp_order_by
  sum: laps_sum_order_by
  var_pop: laps_var_pop_order_by
  var_samp: laps_var_samp_order_by
  variance: laps_variance_order_by
}

"""
input type for inserting array relation for remote table "laps"
"""
input laps_arr_rel_insert_input {
  data: [laps_insert_input!]!

  """
  upsert condition
  """
  on_conflict: laps_on_conflict
}

"""
aggregate avg on columns
"""
type laps_avg_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by avg() on columns of table "laps"
"""
input laps_avg_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
Boolean expression to filter rows from the table "laps". All fields are combined with a logical 'AND'.
"""
input laps_bool_exp {
  _and: [laps_bool_exp!]
  _not: laps_bool_exp
  _or: [laps_bool_exp!]
  compound: tyre_compounds_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  fresh_tyre: Boolean_comparison_exp
  id: String_comparison_exp
  is_accurate: Boolean_comparison_exp
  is_personal_best: Boolean_comparison_exp
  lap_number: Int_comparison_exp
  lap_time: bigint_comparison_exp
  pitin_time: bigint_comparison_exp
  pitout_time: bigint_comparison_exp
  sector1: bigint_comparison_exp
  sector1_ts: bigint_comparison_exp
  sector2: bigint_comparison_exp
  sector2_ts: bigint_comparison_exp
  sector3: bigint_comparison_exp
  sector3_ts: bigint_comparison_exp
  session_time: bigint_comparison_exp
  speed_trap_fastest_lap: numeric_comparison_exp
  speed_trap_sector1: numeric_comparison_exp
  speed_trap_sector2: numeric_comparison_exp
  speed_trap_straight: numeric_comparison_exp
  stint: Int_comparison_exp
  tyre_life: Int_comparison_exp
}

"""
unique or primary key constraints on table "laps"
"""
enum laps_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  laps_pkey
}

"""
input type for incrementing numeric columns in table "laps"
"""
input laps_inc_input {
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
input type for inserting data into table "laps"
"""
input laps_insert_input {
  compound: tyre_compounds
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate max on columns
"""
type laps_max_fields {
  compound: tyre_compounds
  driver_session_id: String
  id: String
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by max() on columns of table "laps"
"""
input laps_max_order_by {
  compound: order_by
  driver_session_id: order_by
  id: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate min on columns
"""
type laps_min_fields {
  compound: tyre_compounds
  driver_session_id: String
  id: String
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by min() on columns of table "laps"
"""
input laps_min_order_by {
  compound: order_by
  driver_session_id: order_by
  id: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
response of any mutation on the table "laps"
"""
type laps_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [laps!]!
}

"""
on_conflict condition type for table "laps"
"""
input laps_on_conflict {
  constraint: laps_constraint!
  update_columns: [laps_update_column!]! = []
  where: laps_bool_exp
}

"""
Ordering options when selecting data from "laps".
"""
input laps_order_by {
  compound: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  fresh_tyre: order_by
  id: order_by
  is_accurate: order_by
  is_personal_best: order_by
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
primary key columns input for table: laps
"""
input laps_pk_columns_input {
  id: String!
}

"""
select columns of table "laps"
"""
enum laps_select_column {
  """
  column name
  """
  compound

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  id

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best

  """
  column name
  """
  lap_number

  """
  column name
  """
  lap_time

  """
  column name
  """
  pitin_time

  """
  column name
  """
  pitout_time

  """
  column name
  """
  sector1

  """
  column name
  """
  sector1_ts

  """
  column name
  """
  sector2

  """
  column name
  """
  sector2_ts

  """
  column name
  """
  sector3

  """
  column name
  """
  sector3_ts

  """
  column name
  """
  session_time

  """
  column name
  """
  speed_trap_fastest_lap

  """
  column name
  """
  speed_trap_sector1

  """
  column name
  """
  speed_trap_sector2

  """
  column name
  """
  speed_trap_straight

  """
  column name
  """
  stint

  """
  column name
  """
  tyre_life
}

"""
select "laps_aggregate_bool_exp_bool_and_arguments_columns" columns of table "laps"
"""
enum laps_select_column_laps_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best
}

"""
select "laps_aggregate_bool_exp_bool_or_arguments_columns" columns of table "laps"
"""
enum laps_select_column_laps_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best
}

"""
input type for updating data in table "laps"
"""
input laps_set_input {
  compound: tyre_compounds
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate stddev on columns
"""
type laps_stddev_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev() on columns of table "laps"
"""
input laps_stddev_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate stddev_pop on columns
"""
type laps_stddev_pop_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev_pop() on columns of table "laps"
"""
input laps_stddev_pop_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate stddev_samp on columns
"""
type laps_stddev_samp_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by stddev_samp() on columns of table "laps"
"""
input laps_stddev_samp_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
Streaming cursor of the table "laps"
"""
input laps_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: laps_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input laps_stream_cursor_value_input {
  compound: tyre_compounds
  driver_session_id: String
  fresh_tyre: Boolean
  id: String
  is_accurate: Boolean
  is_personal_best: Boolean
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
aggregate sum on columns
"""
type laps_sum_fields {
  lap_number: Int
  lap_time: bigint
  pitin_time: bigint
  pitout_time: bigint
  sector1: bigint
  sector1_ts: bigint
  sector2: bigint
  sector2_ts: bigint
  sector3: bigint
  sector3_ts: bigint
  session_time: bigint
  speed_trap_fastest_lap: numeric
  speed_trap_sector1: numeric
  speed_trap_sector2: numeric
  speed_trap_straight: numeric
  stint: Int
  tyre_life: Int
}

"""
order by sum() on columns of table "laps"
"""
input laps_sum_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
update columns of table "laps"
"""
enum laps_update_column {
  """
  column name
  """
  compound

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  fresh_tyre

  """
  column name
  """
  id

  """
  column name
  """
  is_accurate

  """
  column name
  """
  is_personal_best

  """
  column name
  """
  lap_number

  """
  column name
  """
  lap_time

  """
  column name
  """
  pitin_time

  """
  column name
  """
  pitout_time

  """
  column name
  """
  sector1

  """
  column name
  """
  sector1_ts

  """
  column name
  """
  sector2

  """
  column name
  """
  sector2_ts

  """
  column name
  """
  sector3

  """
  column name
  """
  sector3_ts

  """
  column name
  """
  session_time

  """
  column name
  """
  speed_trap_fastest_lap

  """
  column name
  """
  speed_trap_sector1

  """
  column name
  """
  speed_trap_sector2

  """
  column name
  """
  speed_trap_straight

  """
  column name
  """
  stint

  """
  column name
  """
  tyre_life
}

input laps_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: laps_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: laps_set_input

  """
  filter the rows which have to be updated
  """
  where: laps_bool_exp!
}

"""
aggregate var_pop on columns
"""
type laps_var_pop_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by var_pop() on columns of table "laps"
"""
input laps_var_pop_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate var_samp on columns
"""
type laps_var_samp_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by var_samp() on columns of table "laps"
"""
input laps_var_samp_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
aggregate variance on columns
"""
type laps_variance_fields {
  lap_number: Float
  lap_time: Float
  pitin_time: Float
  pitout_time: Float
  sector1: Float
  sector1_ts: Float
  sector2: Float
  sector2_ts: Float
  sector3: Float
  sector3_ts: Float
  session_time: Float
  speed_trap_fastest_lap: Float
  speed_trap_sector1: Float
  speed_trap_sector2: Float
  speed_trap_straight: Float
  stint: Float
  tyre_life: Float
}

"""
order by variance() on columns of table "laps"
"""
input laps_variance_order_by {
  lap_number: order_by
  lap_time: order_by
  pitin_time: order_by
  pitout_time: order_by
  sector1: order_by
  sector1_ts: order_by
  sector2: order_by
  sector2_ts: order_by
  sector3: order_by
  sector3_ts: order_by
  session_time: order_by
  speed_trap_fastest_lap: order_by
  speed_trap_sector1: order_by
  speed_trap_sector2: order_by
  speed_trap_straight: order_by
  stint: order_by
  tyre_life: order_by
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "circuits"
  """
  delete_circuits(
    """
    filter the rows which have to be deleted
    """
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  delete single row from the table: "circuits"
  """
  delete_circuits_by_pk(id: String!): circuits

  """
  delete data from the table: "constructor_standings"
  """
  delete_constructor_standings(
    """
    filter the rows which have to be deleted
    """
    where: constructor_standings_bool_exp!
  ): constructor_standings_mutation_response

  """
  delete single row from the table: "constructor_standings"
  """
  delete_constructor_standings_by_pk(id: String!): constructor_standings

  """
  delete data from the table: "constructors"
  """
  delete_constructors(
    """
    filter the rows which have to be deleted
    """
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  delete single row from the table: "constructors"
  """
  delete_constructors_by_pk(id: String!): constructors

  """
  delete data from the table: "driver_sessions"
  """
  delete_driver_sessions(
    """
    filter the rows which have to be deleted
    """
    where: driver_sessions_bool_exp!
  ): driver_sessions_mutation_response

  """
  delete single row from the table: "driver_sessions"
  """
  delete_driver_sessions_by_pk(id: String!): driver_sessions

  """
  delete data from the table: "driver_standings"
  """
  delete_driver_standings(
    """
    filter the rows which have to be deleted
    """
    where: driver_standings_bool_exp!
  ): driver_standings_mutation_response

  """
  delete single row from the table: "driver_standings"
  """
  delete_driver_standings_by_pk(id: String!): driver_standings

  """
  delete data from the table: "drivers"
  """
  delete_drivers(
    """
    filter the rows which have to be deleted
    """
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  delete single row from the table: "drivers"
  """
  delete_drivers_by_pk(id: String!): drivers

  """
  delete data from the table: "events"
  """
  delete_events(
    """
    filter the rows which have to be deleted
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete single row from the table: "events"
  """
  delete_events_by_pk(id: String!): events

  """
  delete data from the table: "laps"
  """
  delete_laps(
    """
    filter the rows which have to be deleted
    """
    where: laps_bool_exp!
  ): laps_mutation_response

  """
  delete single row from the table: "laps"
  """
  delete_laps_by_pk(id: String!): laps

  """
  delete data from the table: "race_control_messages"
  """
  delete_race_control_messages(
    """
    filter the rows which have to be deleted
    """
    where: race_control_messages_bool_exp!
  ): race_control_messages_mutation_response

  """
  delete single row from the table: "race_control_messages"
  """
  delete_race_control_messages_by_pk(id: String!): race_control_messages

  """
  delete data from the table: "results"
  """
  delete_results(
    """
    filter the rows which have to be deleted
    """
    where: results_bool_exp!
  ): results_mutation_response

  """
  delete single row from the table: "results"
  """
  delete_results_by_pk(id: String!): results

  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    """
    filter the rows which have to be deleted
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(id: String!): sessions

  """
  delete data from the table: "telemetry"
  """
  delete_telemetry(
    """
    filter the rows which have to be deleted
    """
    where: telemetry_bool_exp!
  ): telemetry_mutation_response

  """
  delete single row from the table: "telemetry"
  """
  delete_telemetry_by_pk(id: String!): telemetry

  """
  delete data from the table: "track_status"
  """
  delete_track_status(
    """
    filter the rows which have to be deleted
    """
    where: track_status_bool_exp!
  ): track_status_mutation_response

  """
  delete single row from the table: "track_status"
  """
  delete_track_status_by_pk(id: String!): track_status

  """
  delete data from the table: "weather_data"
  """
  delete_weather_data(
    """
    filter the rows which have to be deleted
    """
    where: weather_data_bool_exp!
  ): weather_data_mutation_response

  """
  delete single row from the table: "weather_data"
  """
  delete_weather_data_by_pk(id: String!): weather_data

  """
  insert data into the table: "circuits"
  """
  insert_circuits(
    """
    the rows to be inserted
    """
    objects: [circuits_insert_input!]!

    """
    upsert condition
    """
    on_conflict: circuits_on_conflict
  ): circuits_mutation_response

  """
  insert a single row into the table: "circuits"
  """
  insert_circuits_one(
    """
    the row to be inserted
    """
    object: circuits_insert_input!

    """
    upsert condition
    """
    on_conflict: circuits_on_conflict
  ): circuits

  """
  insert data into the table: "constructor_standings"
  """
  insert_constructor_standings(
    """
    the rows to be inserted
    """
    objects: [constructor_standings_insert_input!]!

    """
    upsert condition
    """
    on_conflict: constructor_standings_on_conflict
  ): constructor_standings_mutation_response

  """
  insert a single row into the table: "constructor_standings"
  """
  insert_constructor_standings_one(
    """
    the row to be inserted
    """
    object: constructor_standings_insert_input!

    """
    upsert condition
    """
    on_conflict: constructor_standings_on_conflict
  ): constructor_standings

  """
  insert data into the table: "constructors"
  """
  insert_constructors(
    """
    the rows to be inserted
    """
    objects: [constructors_insert_input!]!

    """
    upsert condition
    """
    on_conflict: constructors_on_conflict
  ): constructors_mutation_response

  """
  insert a single row into the table: "constructors"
  """
  insert_constructors_one(
    """
    the row to be inserted
    """
    object: constructors_insert_input!

    """
    upsert condition
    """
    on_conflict: constructors_on_conflict
  ): constructors

  """
  insert data into the table: "driver_sessions"
  """
  insert_driver_sessions(
    """
    the rows to be inserted
    """
    objects: [driver_sessions_insert_input!]!

    """
    upsert condition
    """
    on_conflict: driver_sessions_on_conflict
  ): driver_sessions_mutation_response

  """
  insert a single row into the table: "driver_sessions"
  """
  insert_driver_sessions_one(
    """
    the row to be inserted
    """
    object: driver_sessions_insert_input!

    """
    upsert condition
    """
    on_conflict: driver_sessions_on_conflict
  ): driver_sessions

  """
  insert data into the table: "driver_standings"
  """
  insert_driver_standings(
    """
    the rows to be inserted
    """
    objects: [driver_standings_insert_input!]!

    """
    upsert condition
    """
    on_conflict: driver_standings_on_conflict
  ): driver_standings_mutation_response

  """
  insert a single row into the table: "driver_standings"
  """
  insert_driver_standings_one(
    """
    the row to be inserted
    """
    object: driver_standings_insert_input!

    """
    upsert condition
    """
    on_conflict: driver_standings_on_conflict
  ): driver_standings

  """
  insert data into the table: "drivers"
  """
  insert_drivers(
    """
    the rows to be inserted
    """
    objects: [drivers_insert_input!]!

    """
    upsert condition
    """
    on_conflict: drivers_on_conflict
  ): drivers_mutation_response

  """
  insert a single row into the table: "drivers"
  """
  insert_drivers_one(
    """
    the row to be inserted
    """
    object: drivers_insert_input!

    """
    upsert condition
    """
    on_conflict: drivers_on_conflict
  ): drivers

  """
  insert data into the table: "events"
  """
  insert_events(
    """
    the rows to be inserted
    """
    objects: [events_insert_input!]!

    """
    upsert condition
    """
    on_conflict: events_on_conflict
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """
    the row to be inserted
    """
    object: events_insert_input!

    """
    upsert condition
    """
    on_conflict: events_on_conflict
  ): events

  """
  insert data into the table: "laps"
  """
  insert_laps(
    """
    the rows to be inserted
    """
    objects: [laps_insert_input!]!

    """
    upsert condition
    """
    on_conflict: laps_on_conflict
  ): laps_mutation_response

  """
  insert a single row into the table: "laps"
  """
  insert_laps_one(
    """
    the row to be inserted
    """
    object: laps_insert_input!

    """
    upsert condition
    """
    on_conflict: laps_on_conflict
  ): laps

  """
  insert data into the table: "race_control_messages"
  """
  insert_race_control_messages(
    """
    the rows to be inserted
    """
    objects: [race_control_messages_insert_input!]!

    """
    upsert condition
    """
    on_conflict: race_control_messages_on_conflict
  ): race_control_messages_mutation_response

  """
  insert a single row into the table: "race_control_messages"
  """
  insert_race_control_messages_one(
    """
    the row to be inserted
    """
    object: race_control_messages_insert_input!

    """
    upsert condition
    """
    on_conflict: race_control_messages_on_conflict
  ): race_control_messages

  """
  insert data into the table: "results"
  """
  insert_results(
    """
    the rows to be inserted
    """
    objects: [results_insert_input!]!

    """
    upsert condition
    """
    on_conflict: results_on_conflict
  ): results_mutation_response

  """
  insert a single row into the table: "results"
  """
  insert_results_one(
    """
    the row to be inserted
    """
    object: results_insert_input!

    """
    upsert condition
    """
    on_conflict: results_on_conflict
  ): results

  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    """
    the rows to be inserted
    """
    objects: [sessions_insert_input!]!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    """
    the row to be inserted
    """
    object: sessions_insert_input!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "telemetry"
  """
  insert_telemetry(
    """
    the rows to be inserted
    """
    objects: [telemetry_insert_input!]!

    """
    upsert condition
    """
    on_conflict: telemetry_on_conflict
  ): telemetry_mutation_response

  """
  insert a single row into the table: "telemetry"
  """
  insert_telemetry_one(
    """
    the row to be inserted
    """
    object: telemetry_insert_input!

    """
    upsert condition
    """
    on_conflict: telemetry_on_conflict
  ): telemetry

  """
  insert data into the table: "track_status"
  """
  insert_track_status(
    """
    the rows to be inserted
    """
    objects: [track_status_insert_input!]!

    """
    upsert condition
    """
    on_conflict: track_status_on_conflict
  ): track_status_mutation_response

  """
  insert a single row into the table: "track_status"
  """
  insert_track_status_one(
    """
    the row to be inserted
    """
    object: track_status_insert_input!

    """
    upsert condition
    """
    on_conflict: track_status_on_conflict
  ): track_status

  """
  insert data into the table: "weather_data"
  """
  insert_weather_data(
    """
    the rows to be inserted
    """
    objects: [weather_data_insert_input!]!

    """
    upsert condition
    """
    on_conflict: weather_data_on_conflict
  ): weather_data_mutation_response

  """
  insert a single row into the table: "weather_data"
  """
  insert_weather_data_one(
    """
    the row to be inserted
    """
    object: weather_data_insert_input!

    """
    upsert condition
    """
    on_conflict: weather_data_on_conflict
  ): weather_data

  """
  update data of the table: "circuits"
  """
  update_circuits(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: circuits_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: circuits_set_input

    """
    filter the rows which have to be updated
    """
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  update single row of the table: "circuits"
  """
  update_circuits_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: circuits_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: circuits_set_input
    pk_columns: circuits_pk_columns_input!
  ): circuits

  """
  update multiples rows of table: "circuits"
  """
  update_circuits_many(
    """
    updates to execute, in order
    """
    updates: [circuits_updates!]!
  ): [circuits_mutation_response]

  """
  update data of the table: "constructor_standings"
  """
  update_constructor_standings(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructor_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructor_standings_set_input

    """
    filter the rows which have to be updated
    """
    where: constructor_standings_bool_exp!
  ): constructor_standings_mutation_response

  """
  update single row of the table: "constructor_standings"
  """
  update_constructor_standings_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructor_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructor_standings_set_input
    pk_columns: constructor_standings_pk_columns_input!
  ): constructor_standings

  """
  update multiples rows of table: "constructor_standings"
  """
  update_constructor_standings_many(
    """
    updates to execute, in order
    """
    updates: [constructor_standings_updates!]!
  ): [constructor_standings_mutation_response]

  """
  update data of the table: "constructors"
  """
  update_constructors(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructors_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructors_set_input

    """
    filter the rows which have to be updated
    """
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  update single row of the table: "constructors"
  """
  update_constructors_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: constructors_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: constructors_set_input
    pk_columns: constructors_pk_columns_input!
  ): constructors

  """
  update multiples rows of table: "constructors"
  """
  update_constructors_many(
    """
    updates to execute, in order
    """
    updates: [constructors_updates!]!
  ): [constructors_mutation_response]

  """
  update data of the table: "driver_sessions"
  """
  update_driver_sessions(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_sessions_set_input

    """
    filter the rows which have to be updated
    """
    where: driver_sessions_bool_exp!
  ): driver_sessions_mutation_response

  """
  update single row of the table: "driver_sessions"
  """
  update_driver_sessions_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_sessions_set_input
    pk_columns: driver_sessions_pk_columns_input!
  ): driver_sessions

  """
  update multiples rows of table: "driver_sessions"
  """
  update_driver_sessions_many(
    """
    updates to execute, in order
    """
    updates: [driver_sessions_updates!]!
  ): [driver_sessions_mutation_response]

  """
  update data of the table: "driver_standings"
  """
  update_driver_standings(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: driver_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_standings_set_input

    """
    filter the rows which have to be updated
    """
    where: driver_standings_bool_exp!
  ): driver_standings_mutation_response

  """
  update single row of the table: "driver_standings"
  """
  update_driver_standings_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: driver_standings_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: driver_standings_set_input
    pk_columns: driver_standings_pk_columns_input!
  ): driver_standings

  """
  update multiples rows of table: "driver_standings"
  """
  update_driver_standings_many(
    """
    updates to execute, in order
    """
    updates: [driver_standings_updates!]!
  ): [driver_standings_mutation_response]

  """
  update data of the table: "drivers"
  """
  update_drivers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: drivers_set_input

    """
    filter the rows which have to be updated
    """
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  update single row of the table: "drivers"
  """
  update_drivers_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: drivers_set_input
    pk_columns: drivers_pk_columns_input!
  ): drivers

  """
  update multiples rows of table: "drivers"
  """
  update_drivers_many(
    """
    updates to execute, in order
    """
    updates: [drivers_updates!]!
  ): [drivers_mutation_response]

  """
  update data of the table: "events"
  """
  update_events(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: events_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: events_set_input

    """
    filter the rows which have to be updated
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  update single row of the table: "events"
  """
  update_events_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: events_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: events_set_input
    pk_columns: events_pk_columns_input!
  ): events

  """
  update multiples rows of table: "events"
  """
  update_events_many(
    """
    updates to execute, in order
    """
    updates: [events_updates!]!
  ): [events_mutation_response]

  """
  update data of the table: "laps"
  """
  update_laps(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: laps_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: laps_set_input

    """
    filter the rows which have to be updated
    """
    where: laps_bool_exp!
  ): laps_mutation_response

  """
  update single row of the table: "laps"
  """
  update_laps_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: laps_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: laps_set_input
    pk_columns: laps_pk_columns_input!
  ): laps

  """
  update multiples rows of table: "laps"
  """
  update_laps_many(
    """
    updates to execute, in order
    """
    updates: [laps_updates!]!
  ): [laps_mutation_response]

  """
  update data of the table: "race_control_messages"
  """
  update_race_control_messages(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: race_control_messages_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: race_control_messages_set_input

    """
    filter the rows which have to be updated
    """
    where: race_control_messages_bool_exp!
  ): race_control_messages_mutation_response

  """
  update single row of the table: "race_control_messages"
  """
  update_race_control_messages_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: race_control_messages_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: race_control_messages_set_input
    pk_columns: race_control_messages_pk_columns_input!
  ): race_control_messages

  """
  update multiples rows of table: "race_control_messages"
  """
  update_race_control_messages_many(
    """
    updates to execute, in order
    """
    updates: [race_control_messages_updates!]!
  ): [race_control_messages_mutation_response]

  """
  update data of the table: "results"
  """
  update_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: results_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: results_set_input

    """
    filter the rows which have to be updated
    """
    where: results_bool_exp!
  ): results_mutation_response

  """
  update single row of the table: "results"
  """
  update_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: results_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: results_set_input
    pk_columns: results_pk_columns_input!
  ): results

  """
  update multiples rows of table: "results"
  """
  update_results_many(
    """
    updates to execute, in order
    """
    updates: [results_updates!]!
  ): [results_mutation_response]

  """
  update data of the table: "sessions"
  """
  update_sessions(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: sessions_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input

    """
    filter the rows which have to be updated
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: sessions_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    """
    updates to execute, in order
    """
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]

  """
  update data of the table: "telemetry"
  """
  update_telemetry(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: telemetry_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: telemetry_set_input

    """
    filter the rows which have to be updated
    """
    where: telemetry_bool_exp!
  ): telemetry_mutation_response

  """
  update single row of the table: "telemetry"
  """
  update_telemetry_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: telemetry_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: telemetry_set_input
    pk_columns: telemetry_pk_columns_input!
  ): telemetry

  """
  update multiples rows of table: "telemetry"
  """
  update_telemetry_many(
    """
    updates to execute, in order
    """
    updates: [telemetry_updates!]!
  ): [telemetry_mutation_response]

  """
  update data of the table: "track_status"
  """
  update_track_status(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: track_status_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: track_status_set_input

    """
    filter the rows which have to be updated
    """
    where: track_status_bool_exp!
  ): track_status_mutation_response

  """
  update single row of the table: "track_status"
  """
  update_track_status_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: track_status_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: track_status_set_input
    pk_columns: track_status_pk_columns_input!
  ): track_status

  """
  update multiples rows of table: "track_status"
  """
  update_track_status_many(
    """
    updates to execute, in order
    """
    updates: [track_status_updates!]!
  ): [track_status_mutation_response]

  """
  update data of the table: "weather_data"
  """
  update_weather_data(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: weather_data_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: weather_data_set_input

    """
    filter the rows which have to be updated
    """
    where: weather_data_bool_exp!
  ): weather_data_mutation_response

  """
  update single row of the table: "weather_data"
  """
  update_weather_data_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: weather_data_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: weather_data_set_input
    pk_columns: weather_data_pk_columns_input!
  ): weather_data

  """
  update multiples rows of table: "weather_data"
  """
  update_weather_data_many(
    """
    updates to execute, in order
    """
    updates: [weather_data_updates!]!
  ): [weather_data_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): circuits_aggregate!

  """
  fetch data from the table: "circuits" using primary key columns
  """
  circuits_by_pk(id: String!): circuits

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  fetch data from the table: "constructor_standings" using primary key columns
  """
  constructor_standings_by_pk(id: String!): constructor_standings

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): constructors_aggregate!

  """
  fetch data from the table: "constructors" using primary key columns
  """
  constructors_by_pk(id: String!): constructors

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  fetch data from the table: "driver_sessions" using primary key columns
  """
  driver_sessions_by_pk(id: String!): driver_sessions

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!

  """
  fetch data from the table: "driver_standings" using primary key columns
  """
  driver_standings_by_pk(id: String!): driver_standings

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): drivers_aggregate!

  """
  fetch data from the table: "drivers" using primary key columns
  """
  drivers_by_pk(id: String!): drivers

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  fetch data from the table: "events" using primary key columns
  """
  events_by_pk(id: String!): events

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  fetch data from the table: "laps" using primary key columns
  """
  laps_by_pk(id: String!): laps

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!

  """
  fetch data from the table: "race_control_messages" using primary key columns
  """
  race_control_messages_by_pk(id: String!): race_control_messages

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  fetch data from the table: "results" using primary key columns
  """
  results_by_pk(id: String!): results

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table: "telemetry"
  """
  telemetry(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch aggregated fields from the table: "telemetry"
  """
  telemetry_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!

  """
  fetch data from the table: "telemetry" using primary key columns
  """
  telemetry_by_pk(id: String!): telemetry

  """
  fetch data from the table: "track_status"
  """
  track_status(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  fetch aggregated fields from the table: "track_status"
  """
  track_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  fetch data from the table: "track_status" using primary key columns
  """
  track_status_by_pk(id: String!): track_status

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!

  """
  fetch data from the table: "weather_data" using primary key columns
  """
  weather_data_by_pk(id: String!): weather_data
}

"""
columns and relationships of "race_control_messages"
"""
type race_control_messages {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String!
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric

  """
  An object relationship
  """
  session: sessions
  session_id: String
  status: String
  time: String
}

"""
aggregated selection of "race_control_messages"
"""
type race_control_messages_aggregate {
  aggregate: race_control_messages_aggregate_fields
  nodes: [race_control_messages!]!
}

input race_control_messages_aggregate_bool_exp {
  count: race_control_messages_aggregate_bool_exp_count
}

input race_control_messages_aggregate_bool_exp_count {
  arguments: [race_control_messages_select_column!]
  distinct: Boolean
  filter: race_control_messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "race_control_messages"
"""
type race_control_messages_aggregate_fields {
  avg: race_control_messages_avg_fields
  count(
    columns: [race_control_messages_select_column!]
    distinct: Boolean
  ): Int!
  max: race_control_messages_max_fields
  min: race_control_messages_min_fields
  stddev: race_control_messages_stddev_fields
  stddev_pop: race_control_messages_stddev_pop_fields
  stddev_samp: race_control_messages_stddev_samp_fields
  sum: race_control_messages_sum_fields
  var_pop: race_control_messages_var_pop_fields
  var_samp: race_control_messages_var_samp_fields
  variance: race_control_messages_variance_fields
}

"""
order by aggregate values of table "race_control_messages"
"""
input race_control_messages_aggregate_order_by {
  avg: race_control_messages_avg_order_by
  count: order_by
  max: race_control_messages_max_order_by
  min: race_control_messages_min_order_by
  stddev: race_control_messages_stddev_order_by
  stddev_pop: race_control_messages_stddev_pop_order_by
  stddev_samp: race_control_messages_stddev_samp_order_by
  sum: race_control_messages_sum_order_by
  var_pop: race_control_messages_var_pop_order_by
  var_samp: race_control_messages_var_samp_order_by
  variance: race_control_messages_variance_order_by
}

"""
input type for inserting array relation for remote table "race_control_messages"
"""
input race_control_messages_arr_rel_insert_input {
  data: [race_control_messages_insert_input!]!

  """
  upsert condition
  """
  on_conflict: race_control_messages_on_conflict
}

"""
aggregate avg on columns
"""
type race_control_messages_avg_fields {
  sector: Float
}

"""
order by avg() on columns of table "race_control_messages"
"""
input race_control_messages_avg_order_by {
  sector: order_by
}

"""
Boolean expression to filter rows from the table "race_control_messages". All fields are combined with a logical 'AND'.
"""
input race_control_messages_bool_exp {
  _and: [race_control_messages_bool_exp!]
  _not: race_control_messages_bool_exp
  _or: [race_control_messages_bool_exp!]
  category: race_control_messages_categories_comparison_exp
  flag: race_control_messages_flags_comparison_exp
  id: String_comparison_exp
  message: String_comparison_exp
  racing_number: String_comparison_exp
  scope: race_control_messages_scopes_comparison_exp
  sector: numeric_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  status: String_comparison_exp
  time: String_comparison_exp
}

scalar race_control_messages_categories

"""
Boolean expression to compare columns of type "race_control_messages_categories". All fields are combined with logical 'AND'.
"""
input race_control_messages_categories_comparison_exp {
  _eq: race_control_messages_categories
  _gt: race_control_messages_categories
  _gte: race_control_messages_categories
  _in: [race_control_messages_categories!]
  _is_null: Boolean
  _lt: race_control_messages_categories
  _lte: race_control_messages_categories
  _neq: race_control_messages_categories
  _nin: [race_control_messages_categories!]
}

"""
unique or primary key constraints on table "race_control_messages"
"""
enum race_control_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  race_control_messages_pkey
}

scalar race_control_messages_flags

"""
Boolean expression to compare columns of type "race_control_messages_flags". All fields are combined with logical 'AND'.
"""
input race_control_messages_flags_comparison_exp {
  _eq: race_control_messages_flags
  _gt: race_control_messages_flags
  _gte: race_control_messages_flags
  _in: [race_control_messages_flags!]
  _is_null: Boolean
  _lt: race_control_messages_flags
  _lte: race_control_messages_flags
  _neq: race_control_messages_flags
  _nin: [race_control_messages_flags!]
}

"""
input type for incrementing numeric columns in table "race_control_messages"
"""
input race_control_messages_inc_input {
  sector: numeric
}

"""
input type for inserting data into table "race_control_messages"
"""
input race_control_messages_insert_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session: sessions_obj_rel_insert_input
  session_id: String
  status: String
  time: String
}

"""
aggregate max on columns
"""
type race_control_messages_max_fields {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
order by max() on columns of table "race_control_messages"
"""
input race_control_messages_max_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
aggregate min on columns
"""
type race_control_messages_min_fields {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
order by min() on columns of table "race_control_messages"
"""
input race_control_messages_min_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
response of any mutation on the table "race_control_messages"
"""
type race_control_messages_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [race_control_messages!]!
}

"""
on_conflict condition type for table "race_control_messages"
"""
input race_control_messages_on_conflict {
  constraint: race_control_messages_constraint!
  update_columns: [race_control_messages_update_column!]! = []
  where: race_control_messages_bool_exp
}

"""
Ordering options when selecting data from "race_control_messages".
"""
input race_control_messages_order_by {
  category: order_by
  flag: order_by
  id: order_by
  message: order_by
  racing_number: order_by
  scope: order_by
  sector: order_by
  session: sessions_order_by
  session_id: order_by
  status: order_by
  time: order_by
}

"""
primary key columns input for table: race_control_messages
"""
input race_control_messages_pk_columns_input {
  id: String!
}

scalar race_control_messages_scopes

"""
Boolean expression to compare columns of type "race_control_messages_scopes". All fields are combined with logical 'AND'.
"""
input race_control_messages_scopes_comparison_exp {
  _eq: race_control_messages_scopes
  _gt: race_control_messages_scopes
  _gte: race_control_messages_scopes
  _in: [race_control_messages_scopes!]
  _is_null: Boolean
  _lt: race_control_messages_scopes
  _lte: race_control_messages_scopes
  _neq: race_control_messages_scopes
  _nin: [race_control_messages_scopes!]
}

"""
select columns of table "race_control_messages"
"""
enum race_control_messages_select_column {
  """
  column name
  """
  category

  """
  column name
  """
  flag

  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  racing_number

  """
  column name
  """
  scope

  """
  column name
  """
  sector

  """
  column name
  """
  session_id

  """
  column name
  """
  status

  """
  column name
  """
  time
}

"""
input type for updating data in table "race_control_messages"
"""
input race_control_messages_set_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
aggregate stddev on columns
"""
type race_control_messages_stddev_fields {
  sector: Float
}

"""
order by stddev() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_order_by {
  sector: order_by
}

"""
aggregate stddev_pop on columns
"""
type race_control_messages_stddev_pop_fields {
  sector: Float
}

"""
order by stddev_pop() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_pop_order_by {
  sector: order_by
}

"""
aggregate stddev_samp on columns
"""
type race_control_messages_stddev_samp_fields {
  sector: Float
}

"""
order by stddev_samp() on columns of table "race_control_messages"
"""
input race_control_messages_stddev_samp_order_by {
  sector: order_by
}

"""
Streaming cursor of the table "race_control_messages"
"""
input race_control_messages_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: race_control_messages_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input race_control_messages_stream_cursor_value_input {
  category: race_control_messages_categories
  flag: race_control_messages_flags
  id: String
  message: String
  racing_number: String
  scope: race_control_messages_scopes
  sector: numeric
  session_id: String
  status: String
  time: String
}

"""
aggregate sum on columns
"""
type race_control_messages_sum_fields {
  sector: numeric
}

"""
order by sum() on columns of table "race_control_messages"
"""
input race_control_messages_sum_order_by {
  sector: order_by
}

"""
update columns of table "race_control_messages"
"""
enum race_control_messages_update_column {
  """
  column name
  """
  category

  """
  column name
  """
  flag

  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  racing_number

  """
  column name
  """
  scope

  """
  column name
  """
  sector

  """
  column name
  """
  session_id

  """
  column name
  """
  status

  """
  column name
  """
  time
}

input race_control_messages_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: race_control_messages_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: race_control_messages_set_input

  """
  filter the rows which have to be updated
  """
  where: race_control_messages_bool_exp!
}

"""
aggregate var_pop on columns
"""
type race_control_messages_var_pop_fields {
  sector: Float
}

"""
order by var_pop() on columns of table "race_control_messages"
"""
input race_control_messages_var_pop_order_by {
  sector: order_by
}

"""
aggregate var_samp on columns
"""
type race_control_messages_var_samp_fields {
  sector: Float
}

"""
order by var_samp() on columns of table "race_control_messages"
"""
input race_control_messages_var_samp_order_by {
  sector: order_by
}

"""
aggregate variance on columns
"""
type race_control_messages_variance_fields {
  sector: Float
}

"""
order by variance() on columns of table "race_control_messages"
"""
input race_control_messages_variance_order_by {
  sector: order_by
}

"""
columns and relationships of "results"
"""
type results {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String!
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregated selection of "results"
"""
type results_aggregate {
  aggregate: results_aggregate_fields
  nodes: [results!]!
}

input results_aggregate_bool_exp {
  count: results_aggregate_bool_exp_count
}

input results_aggregate_bool_exp_count {
  arguments: [results_select_column!]
  distinct: Boolean
  filter: results_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "results"
"""
type results_aggregate_fields {
  avg: results_avg_fields
  count(columns: [results_select_column!], distinct: Boolean): Int!
  max: results_max_fields
  min: results_min_fields
  stddev: results_stddev_fields
  stddev_pop: results_stddev_pop_fields
  stddev_samp: results_stddev_samp_fields
  sum: results_sum_fields
  var_pop: results_var_pop_fields
  var_samp: results_var_samp_fields
  variance: results_variance_fields
}

"""
order by aggregate values of table "results"
"""
input results_aggregate_order_by {
  avg: results_avg_order_by
  count: order_by
  max: results_max_order_by
  min: results_min_order_by
  stddev: results_stddev_order_by
  stddev_pop: results_stddev_pop_order_by
  stddev_samp: results_stddev_samp_order_by
  sum: results_sum_order_by
  var_pop: results_var_pop_order_by
  var_samp: results_var_samp_order_by
  variance: results_variance_order_by
}

"""
input type for inserting array relation for remote table "results"
"""
input results_arr_rel_insert_input {
  data: [results_insert_input!]!

  """
  upsert condition
  """
  on_conflict: results_on_conflict
}

"""
aggregate avg on columns
"""
type results_avg_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by avg() on columns of table "results"
"""
input results_avg_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
Boolean expression to filter rows from the table "results". All fields are combined with a logical 'AND'.
"""
input results_bool_exp {
  _and: [results_bool_exp!]
  _not: results_bool_exp
  _or: [results_bool_exp!]
  classified_position: String_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  finishing_position: Int_comparison_exp
  grid_position: Int_comparison_exp
  id: String_comparison_exp
  points: numeric_comparison_exp
  q1_time: bigint_comparison_exp
  q2_time: bigint_comparison_exp
  q3_time: bigint_comparison_exp
  status: String_comparison_exp
  total_race_time: bigint_comparison_exp
}

"""
unique or primary key constraints on table "results"
"""
enum results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  results_pkey
}

"""
input type for incrementing numeric columns in table "results"
"""
input results_inc_input {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  total_race_time: bigint
}

"""
input type for inserting data into table "results"
"""
input results_insert_input {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate max on columns
"""
type results_max_fields {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
order by max() on columns of table "results"
"""
input results_max_order_by {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: order_by
  driver_session_id: order_by

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
aggregate min on columns
"""
type results_min_fields {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
order by min() on columns of table "results"
"""
input results_min_order_by {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: order_by
  driver_session_id: order_by

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
response of any mutation on the table "results"
"""
type results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [results!]!
}

"""
on_conflict condition type for table "results"
"""
input results_on_conflict {
  constraint: results_constraint!
  update_columns: [results_update_column!]! = []
  where: results_bool_exp
}

"""
Ordering options when selecting data from "results".
"""
input results_order_by {
  classified_position: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  finishing_position: order_by
  grid_position: order_by
  id: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  status: order_by
  total_race_time: order_by
}

"""
primary key columns input for table: results
"""
input results_pk_columns_input {
  id: String!
}

"""
select columns of table "results"
"""
enum results_select_column {
  """
  column name
  """
  classified_position

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  finishing_position

  """
  column name
  """
  grid_position

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  q1_time

  """
  column name
  """
  q2_time

  """
  column name
  """
  q3_time

  """
  column name
  """
  status

  """
  column name
  """
  total_race_time
}

"""
input type for updating data in table "results"
"""
input results_set_input {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate stddev on columns
"""
type results_stddev_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev() on columns of table "results"
"""
input results_stddev_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate stddev_pop on columns
"""
type results_stddev_pop_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev_pop() on columns of table "results"
"""
input results_stddev_pop_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate stddev_samp on columns
"""
type results_stddev_samp_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by stddev_samp() on columns of table "results"
"""
input results_stddev_samp_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
Streaming cursor of the table "results"
"""
input results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: results_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input results_stream_cursor_value_input {
  """
  This is either an integer value if the driver is officially classified or one of R (retired), D (disqualified), E (excluded), W (withdrawn), F (failed to qualify) or N (not classified)
  """
  classified_position: String
  driver_session_id: String

  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  id: String
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  status: String
  total_race_time: bigint
}

"""
aggregate sum on columns
"""
type results_sum_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Int
  grid_position: Int
  points: numeric
  q1_time: bigint
  q2_time: bigint
  q3_time: bigint
  total_race_time: bigint
}

"""
order by sum() on columns of table "results"
"""
input results_sum_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
update columns of table "results"
"""
enum results_update_column {
  """
  column name
  """
  classified_position

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  finishing_position

  """
  column name
  """
  grid_position

  """
  column name
  """
  id

  """
  column name
  """
  points

  """
  column name
  """
  q1_time

  """
  column name
  """
  q2_time

  """
  column name
  """
  q3_time

  """
  column name
  """
  status

  """
  column name
  """
  total_race_time
}

input results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: results_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: results_set_input

  """
  filter the rows which have to be updated
  """
  where: results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type results_var_pop_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by var_pop() on columns of table "results"
"""
input results_var_pop_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate var_samp on columns
"""
type results_var_samp_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by var_samp() on columns of table "results"
"""
input results_var_samp_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

"""
aggregate variance on columns
"""
type results_variance_fields {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: Float
  grid_position: Float
  points: Float
  q1_time: Float
  q2_time: Float
  q3_time: Float
  total_race_time: Float
}

"""
order by variance() on columns of table "results"
"""
input results_variance_order_by {
  """
  The drivers finishing position (values only given if session is Race, Qualifying, Sprint Shootout, Sprint, or Sprint Qualifying
  """
  finishing_position: order_by
  grid_position: order_by
  points: order_by
  q1_time: order_by
  q2_time: order_by
  q3_time: order_by
  total_race_time: order_by
}

scalar session_name_choices

"""
Boolean expression to compare columns of type "session_name_choices". All fields are combined with logical 'AND'.
"""
input session_name_choices_comparison_exp {
  _eq: session_name_choices
  _gt: session_name_choices
  _gte: session_name_choices
  _in: [session_name_choices!]
  _is_null: Boolean
  _lt: session_name_choices
  _lte: session_name_choices
  _neq: session_name_choices
  _nin: [session_name_choices!]
}

"""
columns and relationships of "sessions"
"""
type sessions {
  """
  An object relationship
  """
  circuit: circuits
  circuit_id: String
  date: String

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  An object relationship
  """
  event: events
  event_id: String
  id: String!
  name: session_name_choices

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int

  """
  An array relationship
  """
  track_statuses(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  An aggregate relationship
  """
  track_statuses_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!
}

"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

input sessions_aggregate_bool_exp {
  count: sessions_aggregate_bool_exp_count
}

input sessions_aggregate_bool_exp_count {
  arguments: [sessions_select_column!]
  distinct: Boolean
  filter: sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  avg: sessions_avg_fields
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
  stddev: sessions_stddev_fields
  stddev_pop: sessions_stddev_pop_fields
  stddev_samp: sessions_stddev_samp_fields
  sum: sessions_sum_fields
  var_pop: sessions_var_pop_fields
  var_samp: sessions_var_samp_fields
  variance: sessions_variance_fields
}

"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  avg: sessions_avg_order_by
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
  stddev: sessions_stddev_order_by
  stddev_pop: sessions_stddev_pop_order_by
  stddev_samp: sessions_stddev_samp_order_by
  sum: sessions_sum_order_by
  var_pop: sessions_var_pop_order_by
  var_samp: sessions_var_samp_order_by
  variance: sessions_variance_order_by
}

"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!

  """
  upsert condition
  """
  on_conflict: sessions_on_conflict
}

"""
aggregate avg on columns
"""
type sessions_avg_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by avg() on columns of table "sessions"
"""
input sessions_avg_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  circuit: circuits_bool_exp
  circuit_id: String_comparison_exp
  date: String_comparison_exp
  driver_sessions: driver_sessions_bool_exp
  driver_sessions_aggregate: driver_sessions_aggregate_bool_exp
  event: events_bool_exp
  event_id: String_comparison_exp
  id: String_comparison_exp
  name: session_name_choices_comparison_exp
  race_control_messages: race_control_messages_bool_exp
  race_control_messages_aggregate: race_control_messages_aggregate_bool_exp
  scheduled_laps: Int_comparison_exp
  scheduled_start_time: String_comparison_exp
  scheduled_start_time_utc: String_comparison_exp
  start_time: String_comparison_exp
  total_laps: Int_comparison_exp
  track_statuses: track_status_bool_exp
  track_statuses_aggregate: track_status_aggregate_bool_exp
  weather_data: weather_data_bool_exp
  weather_data_aggregate: weather_data_aggregate_bool_exp
}

"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for incrementing numeric columns in table "sessions"
"""
input sessions_inc_input {
  scheduled_laps: Int
  total_laps: Int
}

"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  circuit: circuits_obj_rel_insert_input
  circuit_id: String
  date: String
  driver_sessions: driver_sessions_arr_rel_insert_input
  event: events_obj_rel_insert_input
  event_id: String
  id: String
  name: session_name_choices
  race_control_messages: race_control_messages_arr_rel_insert_input
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
  track_statuses: track_status_arr_rel_insert_input
  weather_data: weather_data_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type sessions_max_fields {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  circuit_id: order_by
  date: order_by
  event_id: order_by
  id: order_by
  name: order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
}

"""
aggregate min on columns
"""
type sessions_min_fields {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  circuit_id: order_by
  date: order_by
  event_id: order_by
  id: order_by
  name: order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
}

"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [sessions!]!
}

"""
input type for inserting object relation for remote table "sessions"
"""
input sessions_obj_rel_insert_input {
  data: sessions_insert_input!

  """
  upsert condition
  """
  on_conflict: sessions_on_conflict
}

"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}

"""
Ordering options when selecting data from "sessions".
"""
input sessions_order_by {
  circuit: circuits_order_by
  circuit_id: order_by
  date: order_by
  driver_sessions_aggregate: driver_sessions_aggregate_order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  name: order_by
  race_control_messages_aggregate: race_control_messages_aggregate_order_by
  scheduled_laps: order_by
  scheduled_start_time: order_by
  scheduled_start_time_utc: order_by
  start_time: order_by
  total_laps: order_by
  track_statuses_aggregate: track_status_aggregate_order_by
  weather_data_aggregate: weather_data_aggregate_order_by
}

"""
primary key columns input for table: sessions
"""
input sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "sessions"
"""
enum sessions_select_column {
  """
  column name
  """
  circuit_id

  """
  column name
  """
  date

  """
  column name
  """
  event_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  scheduled_laps

  """
  column name
  """
  scheduled_start_time

  """
  column name
  """
  scheduled_start_time_utc

  """
  column name
  """
  start_time

  """
  column name
  """
  total_laps
}

"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
aggregate stddev on columns
"""
type sessions_stddev_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev() on columns of table "sessions"
"""
input sessions_stddev_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate stddev_pop on columns
"""
type sessions_stddev_pop_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev_pop() on columns of table "sessions"
"""
input sessions_stddev_pop_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate stddev_samp on columns
"""
type sessions_stddev_samp_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by stddev_samp() on columns of table "sessions"
"""
input sessions_stddev_samp_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: sessions_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input sessions_stream_cursor_value_input {
  circuit_id: String
  date: String
  event_id: String
  id: String
  name: session_name_choices
  scheduled_laps: Int
  scheduled_start_time: String
  scheduled_start_time_utc: String
  start_time: String
  total_laps: Int
}

"""
aggregate sum on columns
"""
type sessions_sum_fields {
  scheduled_laps: Int
  total_laps: Int
}

"""
order by sum() on columns of table "sessions"
"""
input sessions_sum_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
update columns of table "sessions"
"""
enum sessions_update_column {
  """
  column name
  """
  circuit_id

  """
  column name
  """
  date

  """
  column name
  """
  event_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  scheduled_laps

  """
  column name
  """
  scheduled_start_time

  """
  column name
  """
  scheduled_start_time_utc

  """
  column name
  """
  start_time

  """
  column name
  """
  total_laps
}

input sessions_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: sessions_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: sessions_set_input

  """
  filter the rows which have to be updated
  """
  where: sessions_bool_exp!
}

"""
aggregate var_pop on columns
"""
type sessions_var_pop_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by var_pop() on columns of table "sessions"
"""
input sessions_var_pop_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate var_samp on columns
"""
type sessions_var_samp_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by var_samp() on columns of table "sessions"
"""
input sessions_var_samp_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

"""
aggregate variance on columns
"""
type sessions_variance_fields {
  scheduled_laps: Float
  total_laps: Float
}

"""
order by variance() on columns of table "sessions"
"""
input sessions_variance_order_by {
  scheduled_laps: order_by
  total_laps: order_by
}

type subscription_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [circuits_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [circuits_order_by!]

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): circuits_aggregate!

  """
  fetch data from the table: "circuits" using primary key columns
  """
  circuits_by_pk(id: String!): circuits

  """
  fetch data from the table in a streaming manner: "circuits"
  """
  circuits_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [circuits_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: circuits_bool_exp
  ): [circuits!]!

  """
  An array relationship
  """
  constructor_standings(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  An aggregate relationship
  """
  constructor_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructor_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructor_standings_order_by!]

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): constructor_standings_aggregate!

  """
  fetch data from the table: "constructor_standings" using primary key columns
  """
  constructor_standings_by_pk(id: String!): constructor_standings

  """
  fetch data from the table in a streaming manner: "constructor_standings"
  """
  constructor_standings_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [constructor_standings_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: constructor_standings_bool_exp
  ): [constructor_standings!]!

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [constructors_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [constructors_order_by!]

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): constructors_aggregate!

  """
  fetch data from the table: "constructors" using primary key columns
  """
  constructors_by_pk(id: String!): constructors

  """
  fetch data from the table in a streaming manner: "constructors"
  """
  constructors_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [constructors_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: constructors_bool_exp
  ): [constructors!]!

  """
  An array relationship
  """
  driver_sessions(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An aggregate relationship
  """
  driver_sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_sessions_order_by!]

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): driver_sessions_aggregate!

  """
  fetch data from the table: "driver_sessions" using primary key columns
  """
  driver_sessions_by_pk(id: String!): driver_sessions

  """
  fetch data from the table in a streaming manner: "driver_sessions"
  """
  driver_sessions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [driver_sessions_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: driver_sessions_bool_exp
  ): [driver_sessions!]!

  """
  An array relationship
  """
  driver_standings(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  An aggregate relationship
  """
  driver_standings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [driver_standings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [driver_standings_order_by!]

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): driver_standings_aggregate!

  """
  fetch data from the table: "driver_standings" using primary key columns
  """
  driver_standings_by_pk(id: String!): driver_standings

  """
  fetch data from the table in a streaming manner: "driver_standings"
  """
  driver_standings_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [driver_standings_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: driver_standings_bool_exp
  ): [driver_standings!]!

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [drivers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [drivers_order_by!]

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): drivers_aggregate!

  """
  fetch data from the table: "drivers" using primary key columns
  """
  drivers_by_pk(id: String!): drivers

  """
  fetch data from the table in a streaming manner: "drivers"
  """
  drivers_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [drivers_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  fetch data from the table: "events" using primary key columns
  """
  events_by_pk(id: String!): events

  """
  fetch data from the table in a streaming manner: "events"
  """
  events_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [events_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  An array relationship
  """
  laps(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An aggregate relationship
  """
  laps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [laps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [laps_order_by!]

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): laps_aggregate!

  """
  fetch data from the table: "laps" using primary key columns
  """
  laps_by_pk(id: String!): laps

  """
  fetch data from the table in a streaming manner: "laps"
  """
  laps_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [laps_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: laps_bool_exp
  ): [laps!]!

  """
  An array relationship
  """
  race_control_messages(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An aggregate relationship
  """
  race_control_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [race_control_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [race_control_messages_order_by!]

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): race_control_messages_aggregate!

  """
  fetch data from the table: "race_control_messages" using primary key columns
  """
  race_control_messages_by_pk(id: String!): race_control_messages

  """
  fetch data from the table in a streaming manner: "race_control_messages"
  """
  race_control_messages_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [race_control_messages_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: race_control_messages_bool_exp
  ): [race_control_messages!]!

  """
  An array relationship
  """
  results(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An aggregate relationship
  """
  results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [results_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [results_order_by!]

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): results_aggregate!

  """
  fetch data from the table: "results" using primary key columns
  """
  results_by_pk(id: String!): results

  """
  fetch data from the table in a streaming manner: "results"
  """
  results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [results_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: results_bool_exp
  ): [results!]!

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [sessions_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch data from the table: "telemetry"
  """
  telemetry(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch aggregated fields from the table: "telemetry"
  """
  telemetry_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [telemetry_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [telemetry_order_by!]

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): telemetry_aggregate!

  """
  fetch data from the table: "telemetry" using primary key columns
  """
  telemetry_by_pk(id: String!): telemetry

  """
  fetch data from the table in a streaming manner: "telemetry"
  """
  telemetry_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [telemetry_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: telemetry_bool_exp
  ): [telemetry!]!

  """
  fetch data from the table: "track_status"
  """
  track_status(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  fetch aggregated fields from the table: "track_status"
  """
  track_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [track_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [track_status_order_by!]

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): track_status_aggregate!

  """
  fetch data from the table: "track_status" using primary key columns
  """
  track_status_by_pk(id: String!): track_status

  """
  fetch data from the table in a streaming manner: "track_status"
  """
  track_status_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [track_status_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: track_status_bool_exp
  ): [track_status!]!

  """
  An array relationship
  """
  weather_data(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!

  """
  An aggregate relationship
  """
  weather_data_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [weather_data_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [weather_data_order_by!]

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): weather_data_aggregate!

  """
  fetch data from the table: "weather_data" using primary key columns
  """
  weather_data_by_pk(id: String!): weather_data

  """
  fetch data from the table in a streaming manner: "weather_data"
  """
  weather_data_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [weather_data_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: weather_data_bool_exp
  ): [weather_data!]!
}

"""
columns and relationships of "telemetry"
"""
type telemetry {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String

  """
  An object relationship
  """
  driver_session: driver_sessions
  driver_session_id: String
  drs: Int
  gear: Int
  id: String!
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregated selection of "telemetry"
"""
type telemetry_aggregate {
  aggregate: telemetry_aggregate_fields
  nodes: [telemetry!]!
}

input telemetry_aggregate_bool_exp {
  bool_and: telemetry_aggregate_bool_exp_bool_and
  bool_or: telemetry_aggregate_bool_exp_bool_or
  count: telemetry_aggregate_bool_exp_count
}

input telemetry_aggregate_bool_exp_bool_and {
  arguments: telemetry_select_column_telemetry_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Boolean_comparison_exp!
}

input telemetry_aggregate_bool_exp_bool_or {
  arguments: telemetry_select_column_telemetry_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Boolean_comparison_exp!
}

input telemetry_aggregate_bool_exp_count {
  arguments: [telemetry_select_column!]
  distinct: Boolean
  filter: telemetry_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "telemetry"
"""
type telemetry_aggregate_fields {
  avg: telemetry_avg_fields
  count(columns: [telemetry_select_column!], distinct: Boolean): Int!
  max: telemetry_max_fields
  min: telemetry_min_fields
  stddev: telemetry_stddev_fields
  stddev_pop: telemetry_stddev_pop_fields
  stddev_samp: telemetry_stddev_samp_fields
  sum: telemetry_sum_fields
  var_pop: telemetry_var_pop_fields
  var_samp: telemetry_var_samp_fields
  variance: telemetry_variance_fields
}

"""
order by aggregate values of table "telemetry"
"""
input telemetry_aggregate_order_by {
  avg: telemetry_avg_order_by
  count: order_by
  max: telemetry_max_order_by
  min: telemetry_min_order_by
  stddev: telemetry_stddev_order_by
  stddev_pop: telemetry_stddev_pop_order_by
  stddev_samp: telemetry_stddev_samp_order_by
  sum: telemetry_sum_order_by
  var_pop: telemetry_var_pop_order_by
  var_samp: telemetry_var_samp_order_by
  variance: telemetry_variance_order_by
}

"""
input type for inserting array relation for remote table "telemetry"
"""
input telemetry_arr_rel_insert_input {
  data: [telemetry_insert_input!]!

  """
  upsert condition
  """
  on_conflict: telemetry_on_conflict
}

"""
aggregate avg on columns
"""
type telemetry_avg_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by avg() on columns of table "telemetry"
"""
input telemetry_avg_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
Boolean expression to filter rows from the table "telemetry". All fields are combined with a logical 'AND'.
"""
input telemetry_bool_exp {
  _and: [telemetry_bool_exp!]
  _not: telemetry_bool_exp
  _or: [telemetry_bool_exp!]
  brake: Boolean_comparison_exp
  date: String_comparison_exp
  distance: numeric_comparison_exp
  distance_to_driver_ahead: numeric_comparison_exp
  driver_ahead: String_comparison_exp
  driver_session: driver_sessions_bool_exp
  driver_session_id: String_comparison_exp
  drs: Int_comparison_exp
  gear: Int_comparison_exp
  id: String_comparison_exp
  relative_distance: numeric_comparison_exp
  rpm: Int_comparison_exp
  session_time: bigint_comparison_exp
  source: telemetry_sources_comparison_exp
  speed: numeric_comparison_exp
  status: telemetry_car_status_comparison_exp
  throttle: numeric_comparison_exp
  time: bigint_comparison_exp
  x: numeric_comparison_exp
  y: numeric_comparison_exp
  z: numeric_comparison_exp
}

scalar telemetry_car_status

"""
Boolean expression to compare columns of type "telemetry_car_status". All fields are combined with logical 'AND'.
"""
input telemetry_car_status_comparison_exp {
  _eq: telemetry_car_status
  _gt: telemetry_car_status
  _gte: telemetry_car_status
  _in: [telemetry_car_status!]
  _is_null: Boolean
  _lt: telemetry_car_status
  _lte: telemetry_car_status
  _neq: telemetry_car_status
  _nin: [telemetry_car_status!]
}

"""
unique or primary key constraints on table "telemetry"
"""
enum telemetry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  telemetry_pkey
}

"""
input type for incrementing numeric columns in table "telemetry"
"""
input telemetry_inc_input {
  distance: numeric
  distance_to_driver_ahead: numeric
  drs: Int
  gear: Int
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  speed: numeric
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
input type for inserting data into table "telemetry"
"""
input telemetry_insert_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session: driver_sessions_obj_rel_insert_input
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregate max on columns
"""
type telemetry_max_fields {
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by max() on columns of table "telemetry"
"""
input telemetry_max_order_by {
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate min on columns
"""
type telemetry_min_fields {
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by min() on columns of table "telemetry"
"""
input telemetry_min_order_by {
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
response of any mutation on the table "telemetry"
"""
type telemetry_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [telemetry!]!
}

"""
on_conflict condition type for table "telemetry"
"""
input telemetry_on_conflict {
  constraint: telemetry_constraint!
  update_columns: [telemetry_update_column!]! = []
  where: telemetry_bool_exp
}

"""
Ordering options when selecting data from "telemetry".
"""
input telemetry_order_by {
  brake: order_by
  date: order_by
  distance: order_by
  distance_to_driver_ahead: order_by
  driver_ahead: order_by
  driver_session: driver_sessions_order_by
  driver_session_id: order_by
  drs: order_by
  gear: order_by
  id: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  source: order_by
  speed: order_by
  status: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
primary key columns input for table: telemetry
"""
input telemetry_pk_columns_input {
  id: String!
}

"""
select columns of table "telemetry"
"""
enum telemetry_select_column {
  """
  column name
  """
  brake

  """
  column name
  """
  date

  """
  column name
  """
  distance

  """
  column name
  """
  distance_to_driver_ahead

  """
  column name
  """
  driver_ahead

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  drs

  """
  column name
  """
  gear

  """
  column name
  """
  id

  """
  column name
  """
  relative_distance

  """
  column name
  """
  rpm

  """
  column name
  """
  session_time

  """
  column name
  """
  source

  """
  column name
  """
  speed

  """
  column name
  """
  status

  """
  column name
  """
  throttle

  """
  column name
  """
  time

  """
  column name
  """
  x

  """
  column name
  """
  y

  """
  column name
  """
  z
}

"""
select "telemetry_aggregate_bool_exp_bool_and_arguments_columns" columns of table "telemetry"
"""
enum telemetry_select_column_telemetry_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  brake
}

"""
select "telemetry_aggregate_bool_exp_bool_or_arguments_columns" columns of table "telemetry"
"""
enum telemetry_select_column_telemetry_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  brake
}

"""
input type for updating data in table "telemetry"
"""
input telemetry_set_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

scalar telemetry_sources

"""
Boolean expression to compare columns of type "telemetry_sources". All fields are combined with logical 'AND'.
"""
input telemetry_sources_comparison_exp {
  _eq: telemetry_sources
  _gt: telemetry_sources
  _gte: telemetry_sources
  _in: [telemetry_sources!]
  _is_null: Boolean
  _lt: telemetry_sources
  _lte: telemetry_sources
  _neq: telemetry_sources
  _nin: [telemetry_sources!]
}

"""
aggregate stddev on columns
"""
type telemetry_stddev_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev() on columns of table "telemetry"
"""
input telemetry_stddev_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate stddev_pop on columns
"""
type telemetry_stddev_pop_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev_pop() on columns of table "telemetry"
"""
input telemetry_stddev_pop_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate stddev_samp on columns
"""
type telemetry_stddev_samp_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by stddev_samp() on columns of table "telemetry"
"""
input telemetry_stddev_samp_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
Streaming cursor of the table "telemetry"
"""
input telemetry_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: telemetry_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input telemetry_stream_cursor_value_input {
  brake: Boolean
  date: String
  distance: numeric
  distance_to_driver_ahead: numeric
  driver_ahead: String
  driver_session_id: String
  drs: Int
  gear: Int
  id: String
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  source: telemetry_sources
  speed: numeric
  status: telemetry_car_status
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
aggregate sum on columns
"""
type telemetry_sum_fields {
  distance: numeric
  distance_to_driver_ahead: numeric
  drs: Int
  gear: Int
  relative_distance: numeric
  rpm: Int
  session_time: bigint
  speed: numeric
  throttle: numeric
  time: bigint
  x: numeric
  y: numeric
  z: numeric
}

"""
order by sum() on columns of table "telemetry"
"""
input telemetry_sum_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
update columns of table "telemetry"
"""
enum telemetry_update_column {
  """
  column name
  """
  brake

  """
  column name
  """
  date

  """
  column name
  """
  distance

  """
  column name
  """
  distance_to_driver_ahead

  """
  column name
  """
  driver_ahead

  """
  column name
  """
  driver_session_id

  """
  column name
  """
  drs

  """
  column name
  """
  gear

  """
  column name
  """
  id

  """
  column name
  """
  relative_distance

  """
  column name
  """
  rpm

  """
  column name
  """
  session_time

  """
  column name
  """
  source

  """
  column name
  """
  speed

  """
  column name
  """
  status

  """
  column name
  """
  throttle

  """
  column name
  """
  time

  """
  column name
  """
  x

  """
  column name
  """
  y

  """
  column name
  """
  z
}

input telemetry_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: telemetry_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: telemetry_set_input

  """
  filter the rows which have to be updated
  """
  where: telemetry_bool_exp!
}

"""
aggregate var_pop on columns
"""
type telemetry_var_pop_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by var_pop() on columns of table "telemetry"
"""
input telemetry_var_pop_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate var_samp on columns
"""
type telemetry_var_samp_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by var_samp() on columns of table "telemetry"
"""
input telemetry_var_samp_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
aggregate variance on columns
"""
type telemetry_variance_fields {
  distance: Float
  distance_to_driver_ahead: Float
  drs: Float
  gear: Float
  relative_distance: Float
  rpm: Float
  session_time: Float
  speed: Float
  throttle: Float
  time: Float
  x: Float
  y: Float
  z: Float
}

"""
order by variance() on columns of table "telemetry"
"""
input telemetry_variance_order_by {
  distance: order_by
  distance_to_driver_ahead: order_by
  drs: order_by
  gear: order_by
  relative_distance: order_by
  rpm: order_by
  session_time: order_by
  speed: order_by
  throttle: order_by
  time: order_by
  x: order_by
  y: order_by
  z: order_by
}

"""
columns and relationships of "track_status"
"""
type track_status {
  id: String!
  message: String

  """
  An object relationship
  """
  session: sessions
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregated selection of "track_status"
"""
type track_status_aggregate {
  aggregate: track_status_aggregate_fields
  nodes: [track_status!]!
}

input track_status_aggregate_bool_exp {
  count: track_status_aggregate_bool_exp_count
}

input track_status_aggregate_bool_exp_count {
  arguments: [track_status_select_column!]
  distinct: Boolean
  filter: track_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "track_status"
"""
type track_status_aggregate_fields {
  avg: track_status_avg_fields
  count(columns: [track_status_select_column!], distinct: Boolean): Int!
  max: track_status_max_fields
  min: track_status_min_fields
  stddev: track_status_stddev_fields
  stddev_pop: track_status_stddev_pop_fields
  stddev_samp: track_status_stddev_samp_fields
  sum: track_status_sum_fields
  var_pop: track_status_var_pop_fields
  var_samp: track_status_var_samp_fields
  variance: track_status_variance_fields
}

"""
order by aggregate values of table "track_status"
"""
input track_status_aggregate_order_by {
  avg: track_status_avg_order_by
  count: order_by
  max: track_status_max_order_by
  min: track_status_min_order_by
  stddev: track_status_stddev_order_by
  stddev_pop: track_status_stddev_pop_order_by
  stddev_samp: track_status_stddev_samp_order_by
  sum: track_status_sum_order_by
  var_pop: track_status_var_pop_order_by
  var_samp: track_status_var_samp_order_by
  variance: track_status_variance_order_by
}

"""
input type for inserting array relation for remote table "track_status"
"""
input track_status_arr_rel_insert_input {
  data: [track_status_insert_input!]!

  """
  upsert condition
  """
  on_conflict: track_status_on_conflict
}

"""
aggregate avg on columns
"""
type track_status_avg_fields {
  session_time: Float
}

"""
order by avg() on columns of table "track_status"
"""
input track_status_avg_order_by {
  session_time: order_by
}

"""
Boolean expression to filter rows from the table "track_status". All fields are combined with a logical 'AND'.
"""
input track_status_bool_exp {
  _and: [track_status_bool_exp!]
  _not: track_status_bool_exp
  _or: [track_status_bool_exp!]
  id: String_comparison_exp
  message: String_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  session_time: bigint_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "track_status"
"""
enum track_status_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  track_status_pkey
}

"""
input type for incrementing numeric columns in table "track_status"
"""
input track_status_inc_input {
  session_time: bigint
}

"""
input type for inserting data into table "track_status"
"""
input track_status_insert_input {
  id: String
  message: String
  session: sessions_obj_rel_insert_input
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate max on columns
"""
type track_status_max_fields {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
order by max() on columns of table "track_status"
"""
input track_status_max_order_by {
  id: order_by
  message: order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
aggregate min on columns
"""
type track_status_min_fields {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
order by min() on columns of table "track_status"
"""
input track_status_min_order_by {
  id: order_by
  message: order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
response of any mutation on the table "track_status"
"""
type track_status_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [track_status!]!
}

"""
on_conflict condition type for table "track_status"
"""
input track_status_on_conflict {
  constraint: track_status_constraint!
  update_columns: [track_status_update_column!]! = []
  where: track_status_bool_exp
}

"""
Ordering options when selecting data from "track_status".
"""
input track_status_order_by {
  id: order_by
  message: order_by
  session: sessions_order_by
  session_id: order_by
  session_time: order_by
  status: order_by
}

"""
primary key columns input for table: track_status
"""
input track_status_pk_columns_input {
  id: String!
}

"""
select columns of table "track_status"
"""
enum track_status_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  status
}

"""
input type for updating data in table "track_status"
"""
input track_status_set_input {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate stddev on columns
"""
type track_status_stddev_fields {
  session_time: Float
}

"""
order by stddev() on columns of table "track_status"
"""
input track_status_stddev_order_by {
  session_time: order_by
}

"""
aggregate stddev_pop on columns
"""
type track_status_stddev_pop_fields {
  session_time: Float
}

"""
order by stddev_pop() on columns of table "track_status"
"""
input track_status_stddev_pop_order_by {
  session_time: order_by
}

"""
aggregate stddev_samp on columns
"""
type track_status_stddev_samp_fields {
  session_time: Float
}

"""
order by stddev_samp() on columns of table "track_status"
"""
input track_status_stddev_samp_order_by {
  session_time: order_by
}

"""
Streaming cursor of the table "track_status"
"""
input track_status_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: track_status_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input track_status_stream_cursor_value_input {
  id: String
  message: String
  session_id: String
  session_time: bigint
  status: String
}

"""
aggregate sum on columns
"""
type track_status_sum_fields {
  session_time: bigint
}

"""
order by sum() on columns of table "track_status"
"""
input track_status_sum_order_by {
  session_time: order_by
}

"""
update columns of table "track_status"
"""
enum track_status_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  message

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  status
}

input track_status_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: track_status_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: track_status_set_input

  """
  filter the rows which have to be updated
  """
  where: track_status_bool_exp!
}

"""
aggregate var_pop on columns
"""
type track_status_var_pop_fields {
  session_time: Float
}

"""
order by var_pop() on columns of table "track_status"
"""
input track_status_var_pop_order_by {
  session_time: order_by
}

"""
aggregate var_samp on columns
"""
type track_status_var_samp_fields {
  session_time: Float
}

"""
order by var_samp() on columns of table "track_status"
"""
input track_status_var_samp_order_by {
  session_time: order_by
}

"""
aggregate variance on columns
"""
type track_status_variance_fields {
  session_time: Float
}

"""
order by variance() on columns of table "track_status"
"""
input track_status_variance_order_by {
  session_time: order_by
}

scalar tyre_compounds

"""
Boolean expression to compare columns of type "tyre_compounds". All fields are combined with logical 'AND'.
"""
input tyre_compounds_comparison_exp {
  _eq: tyre_compounds
  _gt: tyre_compounds
  _gte: tyre_compounds
  _in: [tyre_compounds!]
  _is_null: Boolean
  _lt: tyre_compounds
  _lte: tyre_compounds
  _neq: tyre_compounds
  _nin: [tyre_compounds!]
}

"""
columns and relationships of "weather_data"
"""
type weather_data {
  air_temperature: numeric
  humidity: numeric
  id: String!
  pressure: numeric
  rainfall: Boolean

  """
  An object relationship
  """
  session: sessions
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregated selection of "weather_data"
"""
type weather_data_aggregate {
  aggregate: weather_data_aggregate_fields
  nodes: [weather_data!]!
}

input weather_data_aggregate_bool_exp {
  bool_and: weather_data_aggregate_bool_exp_bool_and
  bool_or: weather_data_aggregate_bool_exp_bool_or
  count: weather_data_aggregate_bool_exp_count
}

input weather_data_aggregate_bool_exp_bool_and {
  arguments: weather_data_select_column_weather_data_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input weather_data_aggregate_bool_exp_bool_or {
  arguments: weather_data_select_column_weather_data_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input weather_data_aggregate_bool_exp_count {
  arguments: [weather_data_select_column!]
  distinct: Boolean
  filter: weather_data_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "weather_data"
"""
type weather_data_aggregate_fields {
  avg: weather_data_avg_fields
  count(columns: [weather_data_select_column!], distinct: Boolean): Int!
  max: weather_data_max_fields
  min: weather_data_min_fields
  stddev: weather_data_stddev_fields
  stddev_pop: weather_data_stddev_pop_fields
  stddev_samp: weather_data_stddev_samp_fields
  sum: weather_data_sum_fields
  var_pop: weather_data_var_pop_fields
  var_samp: weather_data_var_samp_fields
  variance: weather_data_variance_fields
}

"""
order by aggregate values of table "weather_data"
"""
input weather_data_aggregate_order_by {
  avg: weather_data_avg_order_by
  count: order_by
  max: weather_data_max_order_by
  min: weather_data_min_order_by
  stddev: weather_data_stddev_order_by
  stddev_pop: weather_data_stddev_pop_order_by
  stddev_samp: weather_data_stddev_samp_order_by
  sum: weather_data_sum_order_by
  var_pop: weather_data_var_pop_order_by
  var_samp: weather_data_var_samp_order_by
  variance: weather_data_variance_order_by
}

"""
input type for inserting array relation for remote table "weather_data"
"""
input weather_data_arr_rel_insert_input {
  data: [weather_data_insert_input!]!

  """
  upsert condition
  """
  on_conflict: weather_data_on_conflict
}

"""
aggregate avg on columns
"""
type weather_data_avg_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by avg() on columns of table "weather_data"
"""
input weather_data_avg_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
Boolean expression to filter rows from the table "weather_data". All fields are combined with a logical 'AND'.
"""
input weather_data_bool_exp {
  _and: [weather_data_bool_exp!]
  _not: weather_data_bool_exp
  _or: [weather_data_bool_exp!]
  air_temperature: numeric_comparison_exp
  humidity: numeric_comparison_exp
  id: String_comparison_exp
  pressure: numeric_comparison_exp
  rainfall: Boolean_comparison_exp
  session: sessions_bool_exp
  session_id: String_comparison_exp
  session_time: bigint_comparison_exp
  track_temperature: numeric_comparison_exp
  wind_direction: Int_comparison_exp
  wind_speed: numeric_comparison_exp
}

"""
unique or primary key constraints on table "weather_data"
"""
enum weather_data_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  weather_data_pkey
}

"""
input type for incrementing numeric columns in table "weather_data"
"""
input weather_data_inc_input {
  air_temperature: numeric
  humidity: numeric
  pressure: numeric
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
input type for inserting data into table "weather_data"
"""
input weather_data_insert_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session: sessions_obj_rel_insert_input
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate max on columns
"""
type weather_data_max_fields {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by max() on columns of table "weather_data"
"""
input weather_data_max_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate min on columns
"""
type weather_data_min_fields {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by min() on columns of table "weather_data"
"""
input weather_data_min_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
response of any mutation on the table "weather_data"
"""
type weather_data_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [weather_data!]!
}

"""
on_conflict condition type for table "weather_data"
"""
input weather_data_on_conflict {
  constraint: weather_data_constraint!
  update_columns: [weather_data_update_column!]! = []
  where: weather_data_bool_exp
}

"""
Ordering options when selecting data from "weather_data".
"""
input weather_data_order_by {
  air_temperature: order_by
  humidity: order_by
  id: order_by
  pressure: order_by
  rainfall: order_by
  session: sessions_order_by
  session_id: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
primary key columns input for table: weather_data
"""
input weather_data_pk_columns_input {
  id: String!
}

"""
select columns of table "weather_data"
"""
enum weather_data_select_column {
  """
  column name
  """
  air_temperature

  """
  column name
  """
  humidity

  """
  column name
  """
  id

  """
  column name
  """
  pressure

  """
  column name
  """
  rainfall

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  track_temperature

  """
  column name
  """
  wind_direction

  """
  column name
  """
  wind_speed
}

"""
select "weather_data_aggregate_bool_exp_bool_and_arguments_columns" columns of table "weather_data"
"""
enum weather_data_select_column_weather_data_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  rainfall
}

"""
select "weather_data_aggregate_bool_exp_bool_or_arguments_columns" columns of table "weather_data"
"""
enum weather_data_select_column_weather_data_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  rainfall
}

"""
input type for updating data in table "weather_data"
"""
input weather_data_set_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate stddev on columns
"""
type weather_data_stddev_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev() on columns of table "weather_data"
"""
input weather_data_stddev_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate stddev_pop on columns
"""
type weather_data_stddev_pop_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev_pop() on columns of table "weather_data"
"""
input weather_data_stddev_pop_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate stddev_samp on columns
"""
type weather_data_stddev_samp_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by stddev_samp() on columns of table "weather_data"
"""
input weather_data_stddev_samp_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
Streaming cursor of the table "weather_data"
"""
input weather_data_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: weather_data_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input weather_data_stream_cursor_value_input {
  air_temperature: numeric
  humidity: numeric
  id: String
  pressure: numeric
  rainfall: Boolean
  session_id: String
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
aggregate sum on columns
"""
type weather_data_sum_fields {
  air_temperature: numeric
  humidity: numeric
  pressure: numeric
  session_time: bigint
  track_temperature: numeric
  wind_direction: Int
  wind_speed: numeric
}

"""
order by sum() on columns of table "weather_data"
"""
input weather_data_sum_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
update columns of table "weather_data"
"""
enum weather_data_update_column {
  """
  column name
  """
  air_temperature

  """
  column name
  """
  humidity

  """
  column name
  """
  id

  """
  column name
  """
  pressure

  """
  column name
  """
  rainfall

  """
  column name
  """
  session_id

  """
  column name
  """
  session_time

  """
  column name
  """
  track_temperature

  """
  column name
  """
  wind_direction

  """
  column name
  """
  wind_speed
}

input weather_data_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: weather_data_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: weather_data_set_input

  """
  filter the rows which have to be updated
  """
  where: weather_data_bool_exp!
}

"""
aggregate var_pop on columns
"""
type weather_data_var_pop_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by var_pop() on columns of table "weather_data"
"""
input weather_data_var_pop_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate var_samp on columns
"""
type weather_data_var_samp_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by var_samp() on columns of table "weather_data"
"""
input weather_data_var_samp_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}

"""
aggregate variance on columns
"""
type weather_data_variance_fields {
  air_temperature: Float
  humidity: Float
  pressure: Float
  session_time: Float
  track_temperature: Float
  wind_direction: Float
  wind_speed: Float
}

"""
order by variance() on columns of table "weather_data"
"""
input weather_data_variance_order_by {
  air_temperature: order_by
  humidity: order_by
  pressure: order_by
  session_time: order_by
  track_temperature: order_by
  wind_direction: order_by
  wind_speed: order_by
}
